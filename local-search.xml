<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C语言实现UDP服务器</title>
    <link href="/2022/12/28/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0UDP%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/12/28/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0UDP%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TCP-x2F-IP协议与Winsock网络编程接口"><a href="#1-TCP-x2F-IP协议与Winsock网络编程接口" class="headerlink" title="1 TCP&#x2F;IP协议与Winsock网络编程接口"></a>1 TCP&#x2F;IP协议与Winsock网络编程接口</h2><p>为了方便网络编程，20世纪90年代初，Microsoft联合其他几家公司共同制定了一-套Windows下的网络编程接口，即Winsock规范。它不是一种网络协议，而是-一套开放的、支持多种协议的Windows下的网络编程接口。Winsock可以访问很多种网络协议，可以把它当作﹒些协议的封装。现在的Winsock已经基本上实现了与协议无关。可以使用Winsock束调用多种协议的功能。</p><p>那么，Winsock和TCP&#x2F;IP协议到底有什么关系呢?实际上，Winsock就是TCP&#x2F;IP协议的种封装。你可以通过调用Winsock的接口函数来调用TCP&#x2F;IP的各种功能。例如，我们想用TCP&#x2F;IP协议发送数据，就可以使用Winsock的接口函数send()来调用TCP&#x2F;IP的发送数据功能,Winsock已经封装好了发送数据的功能。</p><h2 id="2-Winsock-的常用API"><a href="#2-Winsock-的常用API" class="headerlink" title="2 Winsock 的常用API"></a>2 Winsock 的常用API</h2><h3 id="2-1-WSAStartup函数"><a href="#2-1-WSAStartup函数" class="headerlink" title="2.1 WSAStartup函数"></a>2.1 WSAStartup函数</h3><p>WSAStartup函数的格式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">WSastartup</span><span class="hljs-params">( WORD wversionRequested,LPWSADATA <span class="hljs-number">1</span>pwSAData)</span>;<br></code></pre></td></tr></table></figure><p>程序在使用Socket之前必须调用WSAStartup函数。</p><ul><li><p>该函数的第一个参数指明程序请求使用的Socket版本，其中高位字节指明修订版本、低位字节指明主版本;</p></li><li><p>操作系统利用第二个参数返回请求的Socket的版本信息。当一个应用程序调用WSAStartup函数时，操作系统根据请求的Socket版本来搜索相应的Socket库、然后将找到的Socket库绑定到该应用程序中。以后应用程序就可以调用所请求的Socket库中的其他Socket函数了。</p></li></ul><p>该函数执行成功后返回0。</p><h3 id="2-2-socket函数"><a href="#2-2-socket函数" class="headerlink" title="2.2 socket函数"></a>2.2 socket函数</h3><p>socket函数的格式为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Socket <span class="hljs-title function_">socket</span><span class="hljs-params">( <span class="hljs-type">int</span> af, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol )</span>;<br></code></pre></td></tr></table></figure><p>应用程序调用socket函数来创建一个能够进行网络通信的套接字。</p><ul><li><p>第一个参数指定应用程序使用的通信协议的协议族，如果使用TCP&#x2F;IP协议族，则该参数置PF_INET，设置通信域(本地(PF_LOCAL),ipv4(PF_INET),ipv6(PF_INET6)。</p></li><li><p>第二个参数指定要创建的套接字类型（流套接字类型为SOCK_STREAM，数据报套接字类型为SOCK_DGRAM)。</p></li><li><p>第三个参数指定应用程序所使用的通信协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议。</p></li></ul><p>如果该函数调用成功，则返回新创建的套接字的描述符，如果失败则返回INVALID_SOCKET。套接字描述符是一个整数类型的值。每个进程的进程空间里都有一个套接字描述符表，该表中存放着套接字描述符和套接字数据结构的对应关系。该表用一个字段存放新创建的套接字的描述符，另一个字段存放套接字数据结构的地址，因此根据套接字描述符就可以找到其对应的套接字数据结构。</p><h3 id="2-3-bind函数"><a href="#2-3-bind函数" class="headerlink" title="2.3 bind函数"></a>2.3 bind函数</h3><p>bind函数的格式为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">( SOCKET s,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr FAR *name, <span class="hljs-type">int</span> namelen)</span>;<br></code></pre></td></tr></table></figure><p>当创建了一个Socket以后，套接字数据结构中有一个默认的IP地址和默认的端口号。一个服务程序必须调用bind函数来给Socket绑定一个IP地址和一个特定的端口号。客户程序一般不必调用bind函数来为其Socket绑定IP地址和端口号。该函数的第一个参数指定待绑定的Socket描述符;第二个参数指定一个sockaddr结构，该结构的定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span></span><br><span class="hljs-class">&#123;</span><br>u _short sa_family;<br><br><span class="hljs-type">char</span> sa_data[ <span class="hljs-number">14</span> ];<br>&#125;;<br></code></pre></td></tr></table></figure><p>sa_family指定地址族，对于TCP&#x2F;IP协议族的套接字，将其置AF_INET。当对TCP&#x2F;IP协议族的套接字进行绑定时，我们通常使用如下所示的另一个地址结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span>&#123;</span><br><br>  <span class="hljs-type">sa_family_t</span>     sin_family;   <span class="hljs-comment">//地址族（Address Family），也就是地址类型</span><br><br>  <span class="hljs-type">uint16_t</span>        sin_port;     <span class="hljs-comment">//16位的端口号</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span>  <span class="hljs-title">sin_addr</span>;</span>     <span class="hljs-comment">//32位IP地址    </span><br><br>  <span class="hljs-type">char</span>  sin_zero[<span class="hljs-number">8</span>];  <span class="hljs-comment">//不使用，一般用0填充</span><br> &#125;;<br></code></pre></td></tr></table></figure><p>其中，sin_family置AF_INET; sin_port指明端口号; sin_addr结构体中只有一个唯一的字段s_addr，它表示IP地址。该字段是一个整数，一般用函数inet_addr()把字符串形式的IP地址转换成无符号长整型的整数值后再赋给s_addr。我们用0来填充sin_zero数组，目的是让sockaddr_in结构的大小与sockaddr结构的大小一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span>&#123;<br>   <span class="hljs-type">in_addr_t</span>  s_addr;  <span class="hljs-comment">//32位的IP地址</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>s_addr 是一个整数，而IP地址是一个字符串，所以需要 inet_addr() 函数进行转换将一个无符号短整型数值转换为网络字节序，即大端模式。</p><h3 id="2-4-recvfrom函数"><a href="#2-4-recvfrom函数" class="headerlink" title="2.4 recvfrom函数"></a>2.4 recvfrom函数</h3><p>recefrom为无连接读函数，函数格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">int</span> buf_len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags,<span class="hljs-keyword">struct</span> sockaddr *from,<span class="hljs-type">int</span> fromlen)</span>;<br></code></pre></td></tr></table></figure><p>从UDP接收数据，返回实际接收的字节数，失败时返回-1</p><ul><li><p>Sockfd:套接字描述符</p></li><li><p>buf:指向内存块的指针</p></li><li><p>buf_len:内存块大小，以字节为单位</p></li><li><p>flags:一般为0</p></li><li><p>from:远端的地址，IP地址和端口号</p></li><li><p>fromlen:远端地址长度</p></li></ul><p>举例：recvfrom(sockfd,buf,8192,0,(struct sockaddr *)&amp;address, sizeof(address)); </p><h3 id="2-5-sendto函数"><a href="#2-5-sendto函数" class="headerlink" title="2.5 sendto函数"></a>2.5 sendto函数</h3><p>sendto为无连接函数，函数格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sendto</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * data, <span class="hljs-type">int</span> data_len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags, <span class="hljs-keyword">struct</span> sockaddr *remaddr,<span class="hljs-type">int</span> remaddr_len）</span><br></code></pre></td></tr></table></figure><p>基于UDP发送数据报，返回实际发送的数据长度，出错时返回－1</p><ul><li><p>sockfd:套接字描述符</p></li><li><p>data:指向要发送数据的指针</p></li><li><p>data_len:数据长度</p></li><li><p>flags:通常为0</p></li><li><p>remaddr:远端地址：IP地址和端口号</p></li><li><p>remaddr_len :地址长度</p></li></ul><p>举例：sendto(sockfd,buf,sizeof(buf),0,(struct sockaddr *)&amp;address, sizeof(address)); </p><h3 id="2-6-closesocket函数"><a href="#2-6-closesocket函数" class="headerlink" title="2.6 closesocket函数"></a>2.6 closesocket函数</h3><p>closesocket函数的格式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">closesocket</span> <span class="hljs-params">( SOCKET s )</span> ;<br></code></pre></td></tr></table></figure><p>closesocket函数用来关闭一个描述符为s的套接字。每个进程中都有一个套接字描述符表，表中的每个套接字描述符都与一个位于操作系统缓冲区中的套接字数据结构相对应，有可能有几个套接字描述符指向同一个套接字数据结构。套接字数据结构中专门有一个字段存放该结构被引用的次数，即有多少个套接字描述符指向该结构。closesocket函数如果执行成功就返回0，否则返回SOCKET_ERROR。</p><h3 id="2-7-WSACleanup函数"><a href="#2-7-WSACleanup函数" class="headerlink" title="2.7 WSACleanup函数"></a>2.7 WSACleanup函数</h3><p>WSACleanup函数的格式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">WSAcleanup</span> <span class="hljs-params">( <span class="hljs-type">void</span> )</span> ;<br></code></pre></td></tr></table></figure><p>应用程序在完成对请求的Socket库的使用后，要调用WSACleanup函数来解除与Socket库的绑定并且释放Socket库所占用的系统资源。</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3 代码实现"></a>3 代码实现</h2><h3 id="3-1-服务端代码实现"><a href="#3-1-服务端代码实现" class="headerlink" title="3.1 服务端代码实现"></a>3.1 服务端代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;winsock2.h&gt;</span><span class="hljs-comment">//为socket2.0  </span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 255</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span> &#123;<br><br><span class="hljs-comment">//返回一个无符号16位整形数，高八位（Socket修订版本）和低八位（主版本） </span><br>WORD socketVersion=MAKEWORD(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">//请求的Socket库，这个结构被用来存储被WSAStartup函数调用后返回的Windows Sockets数据</span><br>WSADATA wsadata;<br><br>SOCKET serveSocket;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serveAddr</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">clientAddr</span>;</span><br><br><span class="hljs-type">int</span> len=<span class="hljs-number">-1</span>;<br><br><span class="hljs-type">int</span> addrLen=<span class="hljs-keyword">sizeof</span>(clientAddr);<br><br><span class="hljs-comment">//缓冲数据</span><br><span class="hljs-type">char</span> receiveData[BUF_SIZE];<br><br><span class="hljs-type">char</span> sendData[BUF_SIZE];<br><br><span class="hljs-comment">//初始化socket库</span><br><span class="hljs-keyword">if</span>(WSAStartup(socketVersion,&amp;wsadata)!=<span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket库初始化失败\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//创建socket</span><br>serveSocket=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);<br><br><span class="hljs-keyword">if</span>(serveSocket==INVALID_SOCKET) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket服务器创建失败&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//设置地址类型、端口号、接收地址</span><br>serveAddr.sin_family=AF_INET;<br>serveAddr.sin_port=htons(<span class="hljs-number">15632</span>);<br><span class="hljs-comment">//监听本机的所有接口</span><br>serveAddr.sin_addr.S_un.S_addr= htonl(INADDR_ANY);<br><br><span class="hljs-comment">//socket绑定设置的IP和端口号</span><br><span class="hljs-keyword">if</span>(bind(serveSocket,(SOCKADDR*)&amp;serveAddr,<span class="hljs-keyword">sizeof</span>(serveAddr))==SOCKET_ERROR) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;绑定IP和端口出现问题\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;服务器开始运行\n&quot;</span>);<br><br><span class="hljs-comment">//接收数据</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>len=recvfrom(serveSocket,receiveData,BUF_SIZE<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,(SOCKADDR*)&amp;clientAddr,&amp;addrLen);<br><span class="hljs-keyword">if</span>(len&gt;<span class="hljs-number">0</span>) &#123;<br>receiveData[len]=<span class="hljs-number">0x00</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;接收到一个连接，IP地址为：%s \n&quot;</span>,inet_ntoa(clientAddr.sin_addr));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;客户端：%s \n&quot;</span>,receiveData);<br>&#125;<br><br><span class="hljs-comment">//响应数据</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;服务器：&quot;</span>);<br>fgets(sendData,<span class="hljs-keyword">sizeof</span>(sendData),<span class="hljs-built_in">stdin</span>);<span class="hljs-comment">//标准流 </span><br>sendData[<span class="hljs-built_in">strlen</span>(sendData)<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>; <br>sendto(serveSocket,sendData,<span class="hljs-built_in">strlen</span>(sendData),<span class="hljs-number">0</span>,(SOCKADDR*)&amp;clientAddr,addrLen);<br>&#125;<br><br>closesocket(serveSocket);<br>WSACleanup();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-客户端代码实现"><a href="#3-2-客户端代码实现" class="headerlink" title="3.2 客户端代码实现"></a>3.2 客户端代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;winsock2.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 255</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span> &#123;<br><br>WORD socketVersion=MAKEWORD(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><br>WSADATA wsadata;<br><br>SOCKET clientSocket;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serveAddr</span>;</span><br><br><span class="hljs-type">int</span> len=<span class="hljs-number">-1</span>;<br><br><span class="hljs-type">int</span> addrLen=<span class="hljs-keyword">sizeof</span>(serveAddr);<br><br><br><span class="hljs-comment">//缓冲数据</span><br><span class="hljs-type">char</span> receiveData[BUF_SIZE];<br><br><span class="hljs-type">char</span> sendData[BUF_SIZE];<br><br><span class="hljs-keyword">if</span>(WSAStartup(socketVersion,&amp;wsadata)!=<span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket库初始化失败\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//创建socket</span><br>clientSocket=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);<br><br><span class="hljs-keyword">if</span>(clientSocket==INVALID_SOCKET) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket客户端创建失败\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(argc==<span class="hljs-number">5</span>) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">clientAddr</span>;</span><br>clientAddr.sin_family=AF_INET;<br>clientAddr.sin_addr.S_un.S_addr=inet_addr(argv[<span class="hljs-number">2</span>]);<br>clientAddr.sin_port=htons(atoi(argv[<span class="hljs-number">3</span>]));<br><span class="hljs-keyword">if</span>(bind(clientSocket,(SOCKADDR*)&amp;clientAddr,<span class="hljs-keyword">sizeof</span>(clientAddr))==SOCKET_ERROR) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;绑定IP和端口出现问题\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>serveAddr.sin_family=AF_INET;<br>serveAddr.sin_port=htons(atoi(argv[<span class="hljs-number">5</span>]));<br>serveAddr.sin_addr.S_un.S_addr=inet_addr(argv[<span class="hljs-number">4</span>]);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//设置地址类型、端口号、接收地址</span><br>serveAddr.sin_family=AF_INET;<br>serveAddr.sin_port=htons(<span class="hljs-number">15632</span>);<br>serveAddr.sin_addr.S_un.S_addr=inet_addr(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">//收发数据</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-comment">//发送数据</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;客户端：&quot;</span>);<br>fgets(sendData,<span class="hljs-keyword">sizeof</span>(sendData),<span class="hljs-built_in">stdin</span>);<br>sendData[<span class="hljs-built_in">strlen</span>(sendData)<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-comment">//不再发送数据</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(sendData,<span class="hljs-string">&quot;bye&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send OK!\n&quot;</span>);<br><br><br>sendto(clientSocket,sendData,<span class="hljs-built_in">strlen</span>(sendData),<span class="hljs-number">0</span>,(SOCKADDR*)&amp;serveAddr,addrLen);<br><span class="hljs-comment">//接收数据</span><br>len=recvfrom(clientSocket,receiveData,BUF_SIZE<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,(SOCKADDR*)&amp;serveAddr,&amp;addrLen);<br><span class="hljs-keyword">if</span>(len&gt;<span class="hljs-number">0</span>) &#123;<br>receiveData[len]=<span class="hljs-number">0x00</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;服务器：%s \n&quot;</span>,receiveData);<br>&#125;<br><br>&#125;<br><br>closesocket(clientSocket);<br>WSACleanup();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-遇到的问题"><a href="#4-遇到的问题" class="headerlink" title="4 遇到的问题"></a>4 遇到的问题</h2><h3 id="4-1-undefined-reference-to’WSAStartup’相关编译错误"><a href="#4-1-undefined-reference-to’WSAStartup’相关编译错误" class="headerlink" title="4.1 undefined reference to’WSAStartup’相关编译错误"></a>4.1 undefined reference to’WSAStartup’相关编译错误</h3><p>打开dev-C++的工具-&gt;编译选项，添加-lws2_32命令即可解决，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202212281323563.png" alt="image-20221228132347388"></p><p><strong>参考资料</strong></p><p><a href="http://c.biancheng.net/view/2359.html">基于UDP的服务器端和客户端 (biancheng.net)</a></p><p><a href="https://blog.csdn.net/qq_31869107/article/details/81234785?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-81234785-blog-111029316.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-81234785-blog-111029316.pc_relevant_recovery_v2&utm_relevant_index=5">Dev C++的undefined reference to ‘__imp_htons’或codeclock的undefined reference to’WSAStartup to@8’相关编译器错</a></p>]]></content>
    
    
    <categories>
      
      <category>计网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
      <tag>UDP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eNSP的使用</title>
    <link href="/2022/12/04/eNSP%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/12/04/eNSP%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、eNSP软件是什么？"><a href="#一、eNSP软件是什么？" class="headerlink" title="一、eNSP软件是什么？"></a>一、eNSP软件是什么？</h1><p>eNSP(Enterprise Network Simulation Platform)是一款由华为提供的、可扩展的、图形化操作的网络仿真工具平台，主要对企业网络路由器、交换机进行软件仿真，完美呈现真实设备实景，支持大型网络模拟，让广大用户有机会在没有真实设备的情况下能够模拟演练，学习网络技术。</p><blockquote><p>以上解释来自于百度百科</p></blockquote><h1 id="二、eNSP软件安装"><a href="#二、eNSP软件安装" class="headerlink" title="二、eNSP软件安装"></a>二、eNSP软件安装</h1><h2 id="2-1-安装包"><a href="#2-1-安装包" class="headerlink" title="2.1 安装包"></a>2.1 安装包</h2><p>由于现在华为官网没有提供eNSP的安装包了，所以需要下载的同学应到网上寻找资源下载对应的版本，下载完之后进入安装界面，只需一直点击下一步即可，安装eNSP的时候会附带安装VirtualBox、Wireshark。</p><h2 id="2-2-安装遇到的坑"><a href="#2-2-安装遇到的坑" class="headerlink" title="2.2 安装遇到的坑"></a>2.2 安装遇到的坑</h2><p>由于个人找到的eNSP版本为1.2.00.510，其附带安装的VirtualBox（版本是5左右的）无法在Windows上运行，所以将其卸载后安装版本6的，但是eNSP不支持，最后看到一篇关于解决VirtualBox不兼容问题的博客，然后将其换为VirtualBox-5.2.44-139111-Win该版本后问题解决。</p><h1 id="三、eNSP的使用"><a href="#三、eNSP的使用" class="headerlink" title="三、eNSP的使用"></a>三、eNSP的使用</h1><h2 id="3-1-主页"><a href="#3-1-主页" class="headerlink" title="3.1 主页"></a>3.1 主页</h2><div align="center"><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211220146783.png" height="60%" width="80%"></div><p>上图所示即为eNSP打开的界面，上面为功能栏，左侧为一些实验器材，中间的样例即为自带可运行的示例，学习提供了关于eNSP的一些使用文档和介绍。</p><h2 id="3-2-拓扑页"><a href="#3-2-拓扑页" class="headerlink" title="3.2 拓扑页"></a>3.2 拓扑页</h2><div align="center"><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211220154865.png" height="60%" width="80%"></div><p>中间即为实验区域，左侧为实验的设备。</p><h3 id="PC配置"><a href="#PC配置" class="headerlink" title="PC配置"></a>PC配置</h3><div align="center"><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211220158012.png" height="40%" width="60%"></div><p>通过PC的配置页面进行IP地址、子网掩码、网关的配置，网关即为该PC连接的路由的IP地址，可以通过对路由器进行DHCP配置，选择DHCP自动分配IP地址。</p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><div align="center"><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211220204861.png" height="40%" width="40%"></div><p>一般常用的路由器即为AR2220、Router路由器，可用通过选择CLI或者双击路由器图标进入类似于DOS黑窗口中进行配置。首先sys进入然后通过 int  g0&#x2F;0&#x2F;0(端点号)选择对应端点，通过ip add ip地址 地址掩码设置该端点的ip地址。</p><h4 id="设置ripv2"><a href="#设置ripv2" class="headerlink" title="设置ripv2"></a>设置ripv2</h4><ol><li><p>对路由器进行配置：rip （进入rip协议的配置）</p></li><li><p>Version 2（选择RIP的版本）</p></li><li><p>Network 网络地址（与该路由直连的网络地址）</p></li><li><p>对相连的路由器都使用以上配置。</p></li><li><p>配置完成后使用dis ip routing-table命令查看路由表，表中存在rip协议的路由对应数据，即为配置成功</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202212041710885.png" alt="image-20221204171038773"></p><h4 id="设置DHCP"><a href="#设置DHCP" class="headerlink" title="设置DHCP"></a>设置DHCP</h4><ol><li><p>Dhcp enable开启DHCP服务</p></li><li><p>Ip pool pool1创建全局地址池pool1</p></li><li><p>getway-list 网关地址 设置分配的网关地址</p></li><li><p>network ip地址 mask 子网掩码 设置全局地址池的范围</p></li><li><p>dns-list 主要DNS 备用DNS 设置DNS</p></li><li><p>excluded-ip-address ip地址 ip地址 设置不参与动态分配的地址，可以是一个范围</p></li><li><p>再进入对应的接口，dhcp select global开启全局地址分配ip</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202212041712625.png" alt="image-20221204171236569"></p><h2 id="3-3-交换机"><a href="#3-3-交换机" class="headerlink" title="3.3 交换机"></a>3.3 交换机</h2><p>ensp中S5700交换机为三层交换机，你可以为它设置ip地址，若无需要可直接使用。</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>以上为本人完成计网作业的一些总结，希望可以帮助到大家。</p><p><strong>参考资料</strong></p><p><a href="https://blog.csdn.net/lushixuan12345/article/details/124227195">【eNSP】解决virtualbox不兼容&#x2F;无法运行问题_擅长开发Bug的Mr.NaCl的博客-CSDN博客</a></p><p><a href="https://www.bilibili.com/read/cv14351927">eNSP的DHCP的三种配置 - 哔哩哔哩 (bilibili.com)</a></p><p><a href="https://blog.csdn.net/weixin_48711866/article/details/121604408">华为ensp路由器动态RIP协议配置</a></p>]]></content>
    
    
    <categories>
      
      <category>计网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
      <tag>ensp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译及运行错误</title>
    <link href="/2022/11/16/%E7%BC%96%E8%AF%91%E5%8F%8A%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF/"/>
    <url>/2022/11/16/%E7%BC%96%E8%AF%91%E5%8F%8A%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="一、编译及运行出错"><a href="#一、编译及运行出错" class="headerlink" title="一、编译及运行出错"></a>一、编译及运行出错</h1><blockquote><p>在一次作业中，将java文件上传至Linux服务器，使用javac命令进行编译，之后用java命令运行编译文件，出现找不到主类，之后想在本地使用命令行运行查找问题，结果直接编译出错，故写下该篇文章记录问题。</p></blockquote><h2 id="1-运行出错"><a href="#1-运行出错" class="headerlink" title="1. 运行出错"></a>1. 运行出错</h2><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211162057891.png" alt="运行出错"></p><p>java程序在Linux运行错误原因：java文件中带有包名，编译后的class文件应该放在该包下，使用以下命令运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java 包名.类名<br></code></pre></td></tr></table></figure><h2 id="2-编译出错"><a href="#2-编译出错" class="headerlink" title="2. 编译出错"></a>2. 编译出错</h2><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211162059530.png" alt="image-20221116205933493"></p><ol><li>Java程序在编译的时候，需要使用JDK开发工具包中的JAVAC.EXE命令，而JDK开发工具包是国际版的，默认是对Unicode的编码格式的源文件进行编译操作。</li><li>因此其他编码格式的源文件需要先转为Unicode格式才能够进行编译。</li><li>在未指定源程序文件的编码格式的情况下，JDK会优先获取操作系统的file.encoding参数，然后JDK就把我们的JAVA源程序从file.encoding编码格式转化为JAVA内部默认的Unicode格式放到内存中。</li><li><strong>如果源文件的编码格式不是file.encoding，就会出现乱码-不能够正确对应的中文而报错。</strong></li><li>javac把转换后的Unicode格式的文件进行编译成class类文件，此时.class文件是Unicode编码的，它暂放在内存中。之后，JDK将此以Unicode编码编译后的.class文件保存到操作系统中形成我们见到的.class文件。</li></ol><p><strong>解决方法</strong>：</p><ol><li>将java文件以ASCII编码格式保存</li><li>使用以下命令进行java程序的编译</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">javac -encoding UTF-8 文件名.java<br></code></pre></td></tr></table></figure><p><strong>参考文章</strong></p><p><a href="https://blog.csdn.net/Tsing1644/article/details/107375558?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-5-107375558-blog-106419663.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-5-107375558-blog-106419663.pc_relevant_default&utm_relevant_index=9">解析java程序编译时编码GBK的不可映射字符的错误</a></p>]]></content>
    
    
    <categories>
      
      <category>问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA建立多级包</title>
    <link href="/2022/11/10/IDEA%E5%BB%BA%E7%AB%8B%E5%A4%9A%E7%BA%A7%E5%8C%85/"/>
    <url>/2022/11/10/IDEA%E5%BB%BA%E7%AB%8B%E5%A4%9A%E7%BA%A7%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="一、建立多级包"><a href="#一、建立多级包" class="headerlink" title="一、建立多级包"></a>一、建立多级包</h1><blockquote><p>由于本人隔一段时间就会遇到该问题并且每次都忘记方法需要查找资料，故写下该片博客记录</p></blockquote><h2 id="1-1-建立Package"><a href="#1-1-建立Package" class="headerlink" title="1.1 建立Package"></a>1.1 建立Package</h2><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101716505.png" alt="步骤一"></p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101717810.png" alt="步骤二"></p><p>建立多级package<strong>中间用.分割</strong></p><h2 id="1-2-建立Directionary"><a href="#1-2-建立Directionary" class="headerlink" title="1.2 建立Directionary"></a>1.2 建立Directionary</h2><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101719735.png" alt="步骤一"></p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101720925.png" alt="步骤二"></p><p>建立多级directionary<strong>中间用&#x2F;分割</strong>，<strong>不能使用.分割，使用.分割建立的为单级directionary</strong></p><h1 id="二、-解决多级包不分离问题"><a href="#二、-解决多级包不分离问题" class="headerlink" title="二、 解决多级包不分离问题"></a>二、 解决多级包不分离问题</h1><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101726557.png" alt="步骤一"></p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101728575.png" alt="步骤二"></p><p>取消选择：Compact Middle Packages，多级目录分离</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101729695.png" alt="步骤三"></p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
      <tag>问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2022/10/30/%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/10/30/%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一、反射机制"><a href="#一、反射机制" class="headerlink" title="一、反射机制"></a>一、反射机制</h1><p>反射机制允许程序在执行期借助Reflection API取得任何类的内部信息（比如成员变量、构造器、成员方法等）并能操作对象的属性和方法，反射在设计模式和框架底层都会用到。</p><p>加载完类之后，在堆中就会产生一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202210301944451.png" alt="三个阶段"></p><h2 id="1-1-Java反射机制可以完成"><a href="#1-1-Java反射机制可以完成" class="headerlink" title="1.1 Java反射机制可以完成"></a>1.1 Java反射机制可以完成</h2><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时得到任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ol><h2 id="1-2-反射主要的类"><a href="#1-2-反射主要的类" class="headerlink" title="1.2 反射主要的类"></a>1.2 反射主要的类</h2><p>java.lang.Class 代表一个类，Class对象表示某个类加载后在堆中的对象</p><p>java.lang.reflect.Method 代表类的方法，Method对象表示某个类的方法</p><p>java.lang.reflect.Field 代表类的成员变量，Field对象表示某个类的成员变量</p><p>java.lang.reflect.Constructor 代表类的构造方法，Constructor对象表示某个类的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//使用反射解决</span><br>    <span class="hljs-comment">//加载类，返回Class类型的对象cls</span><br>    Class cls=Class.forName(<span class="hljs-string">&quot;类的全限定名&quot;</span>);<br>    <span class="hljs-comment">//通过cls获取对象的实例，无参构造器创建</span><br>    Object o=cls.newInstance();<br>    System.out.println(o.getClass());<br>    <span class="hljs-comment">//获取方法对象，将方法看做对象（万物皆对象）</span><br>    <span class="hljs-comment">//只能获取public修饰的方法</span><br>    Method method1=cls.getMethod(<span class="hljs-string">&quot;方法名&quot;</span>);<br>    <span class="hljs-comment">//通过method1调用方法</span><br>    System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>    <span class="hljs-comment">//传统：对象.方法()，反射机制 方法.invoke()</span><br>    method1.invoke(o);<br><br>    <span class="hljs-comment">//Field对象表示表示类的属性</span><br>    <span class="hljs-comment">//getField只能获取public修饰的属性</span><br>    Field nameField=cls.getField(<span class="hljs-string">&quot;属性名&quot;</span>);<br>    System.out.println(nameField.get(o));<br><br>    <span class="hljs-comment">//Constructor对象表示构造器，只能获取public修饰的构造器</span><br>    <span class="hljs-comment">//若无指定类型，获取无参构造器对象</span><br>    Constructor constructor=cls.getConstructor();<br>    System.out.println(constructor);<br><br>    <span class="hljs-comment">//获取有参构造器对象</span><br>    Constructor constructor1=cls.getConstructor(String.class);<br>    System.out.println(constructor1);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-反射优点和缺点"><a href="#1-3-反射优点和缺点" class="headerlink" title="1.3 反射优点和缺点"></a>1.3 反射优点和缺点</h2><p>优点：可以动态的创建和使用对象，使用领灵活，没有反射机制，框架技术失去底层支撑</p><p>缺点：使用反射基本是解释执行，对执行速度有影响</p><h2 id="1-4-反射调用优化"><a href="#1-4-反射调用优化" class="headerlink" title="1.4 反射调用优化"></a>1.4 反射调用优化</h2><p>Method、Field、Constructor对象都有setAccessible()方法，其作用是启动和禁用访问安全检查的开关，参数为true表示反射的对象在使用时取消访问检查，提高反射效率。参数值为false表示反射的对象执行访问检查。</p><h1 id="二、Class类"><a href="#二、Class类" class="headerlink" title="二、Class类"></a>二、Class类</h1><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/image-20221030145407804.png" alt="Class类图"></p><ol><li>如图，Class也是类，继承Object类</li><li>Class类对象不是new出来的，而是系统创建的</li><li>对于某个类的Class类对象，在内存中只有一份，类只加载一次</li><li>每个类的实例都会记得自己由哪个Class实例所生成的</li><li>通过Class的一系列API可以完整的得到一个类的完整结构</li><li>Class对象存放在堆中</li><li>类的字节码二进制数据，放在方法区的，有的地方称为类的元数据（包含方法代码、变量名、方法名、访问权限等）</li></ol><h2 id="2-1-Class类的常用方法"><a href="#2-1-Class类的常用方法" class="headerlink" title="2.1 Class类的常用方法"></a>2.1 Class类的常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;<br>    <span class="hljs-comment">//需要通过反射创建的类的全限定名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">classFullPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;base.reflection.pojo.Cat&quot;</span>;<br>    <span class="hljs-comment">//获取Cat类对应的Class对象</span><br>    <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(classFullPath);<br>    <span class="hljs-comment">//显示cls对象是哪个类的Class对象</span><br>    System.out.println(cls);<br>    <span class="hljs-comment">//输出cls运行类型</span><br>    System.out.println(cls.getClass());<br>    <span class="hljs-comment">//得到包名</span><br>    System.out.println(cls.getPackage().getName());<br>    <span class="hljs-comment">//得到全类名</span><br>    System.out.println(cls.getName());<br>    <span class="hljs-comment">//通过cls创建对象实例</span><br>    <span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> (Cat) cls.newInstance();<br>    System.out.println(cat);<br>    <span class="hljs-comment">//获取对象属性</span><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> cls.getField(<span class="hljs-string">&quot;age&quot;</span>);<br>    System.out.println(age.get(cat));<br>    <span class="hljs-comment">//通过反射给属性赋值</span><br>    age.set(cat, <span class="hljs-number">20</span>);<br>    <span class="hljs-comment">//获取所有public修饰的属性</span><br>    Field[] fields = cls.getFields();<br>    <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>        System.out.println(field);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-获取Class类对象的方法"><a href="#2-2-获取Class类对象的方法" class="headerlink" title="2.2 获取Class类对象的方法"></a>2.2 获取Class类对象的方法</h2><ol><li>已知一个类的全类名，而且类在类路径下，可通过Class的静态方法forName()获取。应用场景：多用于配置文件、读取类的全路径，加载类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;类的全路径&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高。应用场景：多用于参数传递</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls2=Cat.class;<br></code></pre></td></tr></table></figure><ol start="3"><li>已知某个类的实例，调用该实例的getClass()方法获取Class对象。应用场景：通过创建好的对象，获取Class对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls3=cat.getClass();<br></code></pre></td></tr></table></figure><ol start="4"><li>通过类加载器创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassLoader cl=对象.getClass().getClassLoader();<br>Class cls4=cl.loadClass(<span class="hljs-string">&quot;类的全类名&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="5"><li>基本数据类型（八种）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls=基本数据类型.class<br></code></pre></td></tr></table></figure><ol start="6"><li>基本数据类型对应的包装类，可以通过.TYPE得到Class对象(获取的是基本数据类型的Class对象)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls=包装类.TYPE<br></code></pre></td></tr></table></figure><blockquote><p>相同的基本类型和包装类.TYPE获取的Class类对象是同一个</p></blockquote><h2 id="2-3-具有Class对象的类型"><a href="#2-3-具有Class对象的类型" class="headerlink" title="2.3 具有Class对象的类型"></a>2.3 具有Class对象的类型</h2><ol><li>外部类、成员内部类、静态内部类、局部内部类、匿名内部类</li><li>interface：接口</li><li>数组</li><li>enum：枚举</li><li>annotation：注解</li><li>基本数据类型</li><li>void</li></ol><h1 id="三、类加载"><a href="#三、类加载" class="headerlink" title="三、类加载"></a>三、类加载</h1><p>反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载</p><ol><li>静态加载：编译时加载相关的类，如果不存在则报错，依赖性太强</li><li>动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，则不报错，降低了依赖性</li></ol><p><strong>类的加载时机</strong></p><ul><li>当创建对象时（静态加载）</li><li>当子类被加载时，父类也加载（静态加载）</li><li>调用类中的静态成员时（静态加载）</li><li>通过反射（动态加载）</li></ul><p><strong>类的加载过程</strong></p><p>java源码编译为字节码文件进行类的加载（类的加载分为三个阶段，如图），类加载后内存布局情况：类的字节码（二进制数据）存放于方法区，类的Class对象存放于堆区。</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202210301945424.png" alt="类的加载过程"></p><h2 id="3-1-加载阶段"><a href="#3-1-加载阶段" class="headerlink" title="3.1 加载阶段"></a>3.1 加载阶段</h2><p>JVMZ在该阶段的主要目的是将字节码从不同的数据源（可能是class文件、也可能是jar包，甚至网络）转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</p><h2 id="3-2-连接阶段"><a href="#3-2-连接阶段" class="headerlink" title="3.2 连接阶段"></a>3.2 连接阶段</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ol><li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li><li>包括：文件格式验证、元数据验证、字节码验证和符号引用验证</li><li>可以使用-Xverify:none参数关闭大部分的类验证措施，缩短虚拟机加载的时间</li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>JVM会在该阶段对静态变量，分配内存并默认初始化。这些变量所使用的内存都将在方法去中进行分配</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>虚拟机将常量池内的符号引用替换为直接引用的过程</p><h2 id="3-3-初始化"><a href="#3-3-初始化" class="headerlink" title="3.3 初始化"></a>3.3 初始化</h2><ol><li>到初始化阶段才真正开始执行类中定义的Java程序代码，此阶段是执行<clinit>()方法的过程</li><li><clinit>()方法由编译器按语句在源文件中出现的顺序，依次自动收集类中所有的静态变量的赋值动作和静态代码块中的语句，并进行合并。</li><li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁，同步。如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。</li></ol><h1 id="四、反射相关方法的使用"><a href="#四、反射相关方法的使用" class="headerlink" title="四、反射相关方法的使用"></a>四、反射相关方法的使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">public</span> Integer id;<br>    <span class="hljs-keyword">private</span> String address;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(Integer id, String address)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(Integer id)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;编号为：&quot;</span>+id+<span class="hljs-string">&quot;的汽车开始运行&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restart</span><span class="hljs-params">(String address)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;原产地为：&quot;</span>+address+<span class="hljs-string">&quot;的汽车重启&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Car&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, address=&#x27;&quot;</span> + address + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class cls=Class.forName(<span class="hljs-string">&quot;base.reflection.pojo.Car&quot;</span>);<br><br>    <span class="hljs-comment">//无参构造获取car实例</span><br>    Object o=cls.newInstance();<br>    System.out.println(o);<br>    System.out.println(Integer.class);<br>    <span class="hljs-comment">//通过public修饰的构造器创建对象</span><br>    Constructor constructor=cls.getConstructor(Integer.class);<br>    Object o1=constructor.newInstance(<span class="hljs-number">126</span>);<br>    System.out.println(o1);<br>    <span class="hljs-comment">//通过private修饰的构造器创建对象</span><br>    Constructor constructor1=cls.getDeclaredConstructor(Integer.class,String.class);<br>    <span class="hljs-comment">//未设置为true，则不能修改或使用私有属性和方法（下同）</span><br>    constructor1.setAccessible(<span class="hljs-literal">true</span>);<br>    Object o2=constructor1.newInstance(<span class="hljs-number">100</span>,<span class="hljs-string">&quot;新西兰&quot;</span>);<br>    System.out.println(o2);<br><br><br>    <span class="hljs-comment">//修改o的public修饰的属性</span><br>    Field fieldId=cls.getField(<span class="hljs-string">&quot;id&quot;</span>);<br>    fieldId.set(o,<span class="hljs-number">123</span>);<br>    <span class="hljs-comment">//修改o的private修饰的属性</span><br>    Field fieldAddress=cls.getDeclaredField(<span class="hljs-string">&quot;address&quot;</span>);<br>    fieldAddress.setAccessible(<span class="hljs-literal">true</span>);<br>    fieldAddress.set(o,<span class="hljs-string">&quot;冰岛&quot;</span>);<br>    System.out.println(o);<br><br>    <span class="hljs-comment">//调用o的方法</span><br>    Method methodStart=cls.getMethod(<span class="hljs-string">&quot;start&quot;</span>,Integer.class);<br>    methodStart.invoke(o,<span class="hljs-number">6</span>);<br>    <span class="hljs-comment">//调用o的private的方法</span><br>    Method methodRestart=cls.getDeclaredMethod(<span class="hljs-string">&quot;restart&quot;</span>,String.class);<br>    methodRestart.setAccessible(<span class="hljs-literal">true</span>);<br>    methodRestart.invoke(o,<span class="hljs-string">&quot;英国&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>视频资料</strong>：<a href="https://www.bilibili.com/video/BV1g84y1F7df/?from=search&seid=12408684664800836462&spm_id_from=333.337.0.0&vd_source=8e40d0a91b994e176587f5593e189b6a">【韩顺平讲Java】Java反射专题</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云服务器安装Redis</title>
    <link href="/2022/10/25/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Redis/"/>
    <url>/2022/10/25/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="一、安装Redis"><a href="#一、安装Redis" class="headerlink" title="一、安装Redis"></a>一、安装Redis</h2><ol><li>从redis的官网下载redis的安装包，redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></li><li>将redis的安装包通过Xftp上传到云服务上，自己选择一个文件夹存放redis安装包并进行解压</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xzf redis-7.0.0.tar.gz<br></code></pre></td></tr></table></figure><p>解压后如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/image-20221020134406224.png" alt="image-20221020134406224"></p><ol start="3"><li>Redis是基于C语言编写的，需要安装Redis所需要的gcc依赖，使用如下命令安装依赖</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum install -y gcc tcl<br></code></pre></td></tr></table></figure><ol start="4"><li>进入解压后的redis目录,运行编译命令,redis默认的安装路径是在 <code>/usr/local/bin</code>目录下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">make &amp;&amp; make install<br></code></pre></td></tr></table></figure><h2 id="二、开启远程连接"><a href="#二、开启远程连接" class="headerlink" title="二、开启远程连接"></a>二、开启远程连接</h2><ol><li>先找到redis.conf文件，将文件中的bind 127.0.0.1 -::1注释，不然只允许127.0.0.1连接，如下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#bind 127.0.0.1 -::1</span><br></code></pre></td></tr></table></figure><blockquote><p>bind ip是将指定的ip设置为redis的对外开放地址</p></blockquote><ol start="2"><li>将daemonize no修改为damemonize yes，即可后台运行redis</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">daemonize <span class="hljs-built_in">yes</span> <br></code></pre></td></tr></table></figure><ol start="3"><li>查找 # requirepass foobared，将注释去掉，设置连接密码</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">requirepass</span> 连接密码<br></code></pre></td></tr></table></figure><ol start="4"><li>启动redis</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-server redis.conf<br></code></pre></td></tr></table></figure><ol start="5"><li>本地连接redis成功<br><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/image-20221020140807427.png" alt="image-20221020140807427"></li></ol>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
