<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>eNSP的使用</title>
    <link href="/2022/12/04/eNSP%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/12/04/eNSP%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、eNSP软件是什么？"><a href="#一、eNSP软件是什么？" class="headerlink" title="一、eNSP软件是什么？"></a>一、eNSP软件是什么？</h1><p>eNSP(Enterprise Network Simulation Platform)是一款由华为提供的、可扩展的、图形化操作的网络仿真工具平台，主要对企业网络路由器、交换机进行软件仿真，完美呈现真实设备实景，支持大型网络模拟，让广大用户有机会在没有真实设备的情况下能够模拟演练，学习网络技术。</p><blockquote><p>以上解释来自于百度百科</p></blockquote><h1 id="二、eNSP软件安装"><a href="#二、eNSP软件安装" class="headerlink" title="二、eNSP软件安装"></a>二、eNSP软件安装</h1><h2 id="2-1-安装包"><a href="#2-1-安装包" class="headerlink" title="2.1 安装包"></a>2.1 安装包</h2><p>由于现在华为官网没有提供eNSP的安装包了，所以需要下载的同学应到网上寻找资源下载对应的版本，下载完之后进入安装界面，只需一直点击下一步即可，安装eNSP的时候会附带安装VirtualBox、Wireshark。</p><h2 id="2-2-安装遇到的坑"><a href="#2-2-安装遇到的坑" class="headerlink" title="2.2 安装遇到的坑"></a>2.2 安装遇到的坑</h2><p>由于个人找到的eNSP版本为1.2.00.510，其附带安装的VirtualBox（版本是5左右的）无法在Windows上运行，所以将其卸载后安装版本6的，但是eNSP不支持，最后看到一篇关于解决VirtualBox不兼容问题的博客，然后将其换为VirtualBox-5.2.44-139111-Win该版本后问题解决。</p><h1 id="三、eNSP的使用"><a href="#三、eNSP的使用" class="headerlink" title="三、eNSP的使用"></a>三、eNSP的使用</h1><h2 id="3-1-主页"><a href="#3-1-主页" class="headerlink" title="3.1 主页"></a>3.1 主页</h2><div align="center"><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211220146783.png" height="60%" width="80%"></div><p>上图所示即为eNSP打开的界面，上面为功能栏，左侧为一些实验器材，中间的样例即为自带可运行的示例，学习提供了关于eNSP的一些使用文档和介绍。</p><h2 id="3-2-拓扑页"><a href="#3-2-拓扑页" class="headerlink" title="3.2 拓扑页"></a>3.2 拓扑页</h2><div align="center"><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211220154865.png" height="60%" width="80%"></div><p>中间即为实验区域，左侧为实验的设备。</p><h3 id="PC配置"><a href="#PC配置" class="headerlink" title="PC配置"></a>PC配置</h3><div align="center"><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211220158012.png" height="40%" width="60%"></div><p>通过PC的配置页面进行IP地址、子网掩码、网关的配置，网关即为该PC连接的路由的IP地址，可以通过对路由器进行DHCP配置，选择DHCP自动分配IP地址。</p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><div align="center"><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211220204861.png" height="40%" width="40%"></div><p>一般常用的路由器即为AR2220、Router路由器，可用通过选择CLI或者双击路由器图标进入类似于DOS黑窗口中进行配置。首先sys进入然后通过 int  g0&#x2F;0&#x2F;0(端点号)选择对应端点，通过ip add ip地址 地址掩码设置该端点的ip地址。</p><h4 id="设置ripv2"><a href="#设置ripv2" class="headerlink" title="设置ripv2"></a>设置ripv2</h4><ol><li><p>对路由器进行配置：rip （进入rip协议的配置）</p></li><li><p>Version 2（选择RIP的版本）</p></li><li><p>Network 网络地址（与该路由直连的网络地址）</p></li><li><p>对相连的路由器都使用以上配置。</p></li><li><p>配置完成后使用dis ip routing-table命令查看路由表，表中存在rip协议的路由对应数据，即为配置成功</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202212041710885.png" alt="image-20221204171038773"></p><h4 id="设置DHCP"><a href="#设置DHCP" class="headerlink" title="设置DHCP"></a>设置DHCP</h4><ol><li><p>Dhcp enable开启DHCP服务</p></li><li><p>Ip pool pool1创建全局地址池pool1</p></li><li><p>getway-list 网关地址 设置分配的网关地址</p></li><li><p>network ip地址 mask 子网掩码 设置全局地址池的范围</p></li><li><p>dns-list 主要DNS 备用DNS 设置DNS</p></li><li><p>excluded-ip-address ip地址 ip地址 设置不参与动态分配的地址，可以是一个范围</p></li><li><p>再进入对应的接口，dhcp select global开启全局地址分配ip</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202212041712625.png" alt="image-20221204171236569"></p><h3 id="3-3-交换机"><a href="#3-3-交换机" class="headerlink" title="3.3 交换机"></a>3.3 交换机</h3><p>ensp中S5700交换机为三层交换机，你可以为它设置ip地址，若无需要可直接使用。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>以上为本人完成计网作业的一些总结，希望可以帮助到大家。</p><p><strong>参考资料</strong></p><p><a href="https://blog.csdn.net/lushixuan12345/article/details/124227195">【eNSP】解决virtualbox不兼容&#x2F;无法运行问题_擅长开发Bug的Mr.NaCl的博客-CSDN博客</a></p><p><a href="https://www.bilibili.com/read/cv14351927">eNSP的DHCP的三种配置 - 哔哩哔哩 (bilibili.com)</a></p><p><a href="https://blog.csdn.net/weixin_48711866/article/details/121604408">华为ensp路由器动态RIP协议配置</a></p>]]></content>
    
    
    <categories>
      
      <category>计网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
      <tag>ensp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译及运行错误</title>
    <link href="/2022/11/16/%E7%BC%96%E8%AF%91%E5%8F%8A%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF/"/>
    <url>/2022/11/16/%E7%BC%96%E8%AF%91%E5%8F%8A%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="一、编译及运行出错"><a href="#一、编译及运行出错" class="headerlink" title="一、编译及运行出错"></a>一、编译及运行出错</h1><blockquote><p>在一次作业中，将java文件上传至Linux服务器，使用javac命令进行编译，之后用java命令运行编译文件，出现找不到主类，之后想在本地使用命令行运行查找问题，结果直接编译出错，故写下该篇文章记录问题。</p></blockquote><h2 id="1-运行出错"><a href="#1-运行出错" class="headerlink" title="1. 运行出错"></a>1. 运行出错</h2><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211162057891.png" alt="运行出错"></p><p>java程序在Linux运行错误原因：java文件中带有包名，编译后的class文件应该放在该包下，使用以下命令运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java 包名.类名<br></code></pre></td></tr></table></figure><h2 id="2-编译出错"><a href="#2-编译出错" class="headerlink" title="2. 编译出错"></a>2. 编译出错</h2><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211162059530.png" alt="image-20221116205933493"></p><ol><li>Java程序在编译的时候，需要使用JDK开发工具包中的JAVAC.EXE命令，而JDK开发工具包是国际版的，默认是对Unicode的编码格式的源文件进行编译操作。</li><li>因此其他编码格式的源文件需要先转为Unicode格式才能够进行编译。</li><li>在未指定源程序文件的编码格式的情况下，JDK会优先获取操作系统的file.encoding参数，然后JDK就把我们的JAVA源程序从file.encoding编码格式转化为JAVA内部默认的Unicode格式放到内存中。</li><li><strong>如果源文件的编码格式不是file.encoding，就会出现乱码-不能够正确对应的中文而报错。</strong></li><li>javac把转换后的Unicode格式的文件进行编译成class类文件，此时.class文件是Unicode编码的，它暂放在内存中。之后，JDK将此以Unicode编码编译后的.class文件保存到操作系统中形成我们见到的.class文件。</li></ol><p><strong>解决方法</strong>：</p><ol><li>将java文件以ASCII编码格式保存</li><li>使用以下命令进行java程序的编译</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">javac -encoding UTF-8 文件名.java<br></code></pre></td></tr></table></figure><p><strong>参考文章</strong></p><p><a href="https://blog.csdn.net/Tsing1644/article/details/107375558?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-5-107375558-blog-106419663.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-5-107375558-blog-106419663.pc_relevant_default&utm_relevant_index=9">解析java程序编译时编码GBK的不可映射字符的错误</a></p>]]></content>
    
    
    <categories>
      
      <category>问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA建立多级包</title>
    <link href="/2022/11/10/IDEA%E5%BB%BA%E7%AB%8B%E5%A4%9A%E7%BA%A7%E5%8C%85/"/>
    <url>/2022/11/10/IDEA%E5%BB%BA%E7%AB%8B%E5%A4%9A%E7%BA%A7%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="一、建立多级包"><a href="#一、建立多级包" class="headerlink" title="一、建立多级包"></a>一、建立多级包</h1><blockquote><p>由于本人隔一段时间就会遇到该问题并且每次都忘记方法需要查找资料，故写下该片博客记录</p></blockquote><h2 id="1-1-建立Package"><a href="#1-1-建立Package" class="headerlink" title="1.1 建立Package"></a>1.1 建立Package</h2><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101716505.png" alt="步骤一"></p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101717810.png" alt="步骤二"></p><p>建立多级package<strong>中间用.分割</strong></p><h2 id="1-2-建立Directionary"><a href="#1-2-建立Directionary" class="headerlink" title="1.2 建立Directionary"></a>1.2 建立Directionary</h2><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101719735.png" alt="步骤一"></p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101720925.png" alt="步骤二"></p><p>建立多级directionary<strong>中间用&#x2F;分割</strong>，<strong>不能使用.分割，使用.分割建立的为单级directionary</strong></p><h1 id="二、-解决多级包不分离问题"><a href="#二、-解决多级包不分离问题" class="headerlink" title="二、 解决多级包不分离问题"></a>二、 解决多级包不分离问题</h1><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101726557.png" alt="步骤一"></p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101728575.png" alt="步骤二"></p><p>取消选择：Compact Middle Packages，多级目录分离</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101729695.png" alt="步骤三"></p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
      <tag>问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2022/10/30/%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/10/30/%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一、反射机制"><a href="#一、反射机制" class="headerlink" title="一、反射机制"></a>一、反射机制</h1><p>反射机制允许程序在执行期借助Reflection API取得任何类的内部信息（比如成员变量、构造器、成员方法等）并能操作对象的属性和方法，反射在设计模式和框架底层都会用到。</p><p>加载完类之后，在堆中就会产生一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202210301944451.png" alt="三个阶段"></p><h2 id="1-1-Java反射机制可以完成"><a href="#1-1-Java反射机制可以完成" class="headerlink" title="1.1 Java反射机制可以完成"></a>1.1 Java反射机制可以完成</h2><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时得到任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ol><h2 id="1-2-反射主要的类"><a href="#1-2-反射主要的类" class="headerlink" title="1.2 反射主要的类"></a>1.2 反射主要的类</h2><p>java.lang.Class 代表一个类，Class对象表示某个类加载后在堆中的对象</p><p>java.lang.reflect.Method 代表类的方法，Method对象表示某个类的方法</p><p>java.lang.reflect.Field 代表类的成员变量，Field对象表示某个类的成员变量</p><p>java.lang.reflect.Constructor 代表类的构造方法，Constructor对象表示某个类的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//使用反射解决</span><br>    <span class="hljs-comment">//加载类，返回Class类型的对象cls</span><br>    Class cls=Class.forName(<span class="hljs-string">&quot;类的全限定名&quot;</span>);<br>    <span class="hljs-comment">//通过cls获取对象的实例，无参构造器创建</span><br>    Object o=cls.newInstance();<br>    System.out.println(o.getClass());<br>    <span class="hljs-comment">//获取方法对象，将方法看做对象（万物皆对象）</span><br>    <span class="hljs-comment">//只能获取public修饰的方法</span><br>    Method method1=cls.getMethod(<span class="hljs-string">&quot;方法名&quot;</span>);<br>    <span class="hljs-comment">//通过method1调用方法</span><br>    System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>    <span class="hljs-comment">//传统：对象.方法()，反射机制 方法.invoke()</span><br>    method1.invoke(o);<br><br>    <span class="hljs-comment">//Field对象表示表示类的属性</span><br>    <span class="hljs-comment">//getField只能获取public修饰的属性</span><br>    Field nameField=cls.getField(<span class="hljs-string">&quot;属性名&quot;</span>);<br>    System.out.println(nameField.get(o));<br><br>    <span class="hljs-comment">//Constructor对象表示构造器，只能获取public修饰的构造器</span><br>    <span class="hljs-comment">//若无指定类型，获取无参构造器对象</span><br>    Constructor constructor=cls.getConstructor();<br>    System.out.println(constructor);<br><br>    <span class="hljs-comment">//获取有参构造器对象</span><br>    Constructor constructor1=cls.getConstructor(String.class);<br>    System.out.println(constructor1);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-反射优点和缺点"><a href="#1-3-反射优点和缺点" class="headerlink" title="1.3 反射优点和缺点"></a>1.3 反射优点和缺点</h2><p>优点：可以动态的创建和使用对象，使用领灵活，没有反射机制，框架技术失去底层支撑</p><p>缺点：使用反射基本是解释执行，对执行速度有影响</p><h2 id="1-4-反射调用优化"><a href="#1-4-反射调用优化" class="headerlink" title="1.4 反射调用优化"></a>1.4 反射调用优化</h2><p>Method、Field、Constructor对象都有setAccessible()方法，其作用是启动和禁用访问安全检查的开关，参数为true表示反射的对象在使用时取消访问检查，提高反射效率。参数值为false表示反射的对象执行访问检查。</p><h1 id="二、Class类"><a href="#二、Class类" class="headerlink" title="二、Class类"></a>二、Class类</h1><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/image-20221030145407804.png" alt="Class类图"></p><ol><li>如图，Class也是类，继承Object类</li><li>Class类对象不是new出来的，而是系统创建的</li><li>对于某个类的Class类对象，在内存中只有一份，类只加载一次</li><li>每个类的实例都会记得自己由哪个Class实例所生成的</li><li>通过Class的一系列API可以完整的得到一个类的完整结构</li><li>Class对象存放在堆中</li><li>类的字节码二进制数据，放在方法区的，有的地方称为类的元数据（包含方法代码、变量名、方法名、访问权限等）</li></ol><h2 id="2-1-Class类的常用方法"><a href="#2-1-Class类的常用方法" class="headerlink" title="2.1 Class类的常用方法"></a>2.1 Class类的常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;<br>    <span class="hljs-comment">//需要通过反射创建的类的全限定名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">classFullPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;base.reflection.pojo.Cat&quot;</span>;<br>    <span class="hljs-comment">//获取Cat类对应的Class对象</span><br>    <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(classFullPath);<br>    <span class="hljs-comment">//显示cls对象是哪个类的Class对象</span><br>    System.out.println(cls);<br>    <span class="hljs-comment">//输出cls运行类型</span><br>    System.out.println(cls.getClass());<br>    <span class="hljs-comment">//得到包名</span><br>    System.out.println(cls.getPackage().getName());<br>    <span class="hljs-comment">//得到全类名</span><br>    System.out.println(cls.getName());<br>    <span class="hljs-comment">//通过cls创建对象实例</span><br>    <span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> (Cat) cls.newInstance();<br>    System.out.println(cat);<br>    <span class="hljs-comment">//获取对象属性</span><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> cls.getField(<span class="hljs-string">&quot;age&quot;</span>);<br>    System.out.println(age.get(cat));<br>    <span class="hljs-comment">//通过反射给属性赋值</span><br>    age.set(cat, <span class="hljs-number">20</span>);<br>    <span class="hljs-comment">//获取所有public修饰的属性</span><br>    Field[] fields = cls.getFields();<br>    <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>        System.out.println(field);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-获取Class类对象的方法"><a href="#2-2-获取Class类对象的方法" class="headerlink" title="2.2 获取Class类对象的方法"></a>2.2 获取Class类对象的方法</h2><ol><li>已知一个类的全类名，而且类在类路径下，可通过Class的静态方法forName()获取。应用场景：多用于配置文件、读取类的全路径，加载类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;类的全路径&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高。应用场景：多用于参数传递</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls2=Cat.class;<br></code></pre></td></tr></table></figure><ol start="3"><li>已知某个类的实例，调用该实例的getClass()方法获取Class对象。应用场景：通过创建好的对象，获取Class对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls3=cat.getClass();<br></code></pre></td></tr></table></figure><ol start="4"><li>通过类加载器创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassLoader cl=对象.getClass().getClassLoader();<br>Class cls4=cl.loadClass(<span class="hljs-string">&quot;类的全类名&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="5"><li>基本数据类型（八种）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls=基本数据类型.class<br></code></pre></td></tr></table></figure><ol start="6"><li>基本数据类型对应的包装类，可以通过.TYPE得到Class对象(获取的是基本数据类型的Class对象)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls=包装类.TYPE<br></code></pre></td></tr></table></figure><blockquote><p>相同的基本类型和包装类.TYPE获取的Class类对象是同一个</p></blockquote><h2 id="2-3-具有Class对象的类型"><a href="#2-3-具有Class对象的类型" class="headerlink" title="2.3 具有Class对象的类型"></a>2.3 具有Class对象的类型</h2><ol><li>外部类、成员内部类、静态内部类、局部内部类、匿名内部类</li><li>interface：接口</li><li>数组</li><li>enum：枚举</li><li>annotation：注解</li><li>基本数据类型</li><li>void</li></ol><h1 id="三、类加载"><a href="#三、类加载" class="headerlink" title="三、类加载"></a>三、类加载</h1><p>反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载</p><ol><li>静态加载：编译时加载相关的类，如果不存在则报错，依赖性太强</li><li>动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，则不报错，降低了依赖性</li></ol><p><strong>类的加载时机</strong></p><ul><li>当创建对象时（静态加载）</li><li>当子类被加载时，父类也加载（静态加载）</li><li>调用类中的静态成员时（静态加载）</li><li>通过反射（动态加载）</li></ul><p><strong>类的加载过程</strong></p><p>java源码编译为字节码文件进行类的加载（类的加载分为三个阶段，如图），类加载后内存布局情况：类的字节码（二进制数据）存放于方法区，类的Class对象存放于堆区。</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202210301945424.png" alt="类的加载过程"></p><h2 id="3-1-加载阶段"><a href="#3-1-加载阶段" class="headerlink" title="3.1 加载阶段"></a>3.1 加载阶段</h2><p>JVMZ在该阶段的主要目的是将字节码从不同的数据源（可能是class文件、也可能是jar包，甚至网络）转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</p><h2 id="3-2-连接阶段"><a href="#3-2-连接阶段" class="headerlink" title="3.2 连接阶段"></a>3.2 连接阶段</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ol><li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li><li>包括：文件格式验证、元数据验证、字节码验证和符号引用验证</li><li>可以使用-Xverify:none参数关闭大部分的类验证措施，缩短虚拟机加载的时间</li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>JVM会在该阶段对静态变量，分配内存并默认初始化。这些变量所使用的内存都将在方法去中进行分配</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>虚拟机将常量池内的符号引用替换为直接引用的过程</p><h2 id="3-3-初始化"><a href="#3-3-初始化" class="headerlink" title="3.3 初始化"></a>3.3 初始化</h2><ol><li>到初始化阶段才真正开始执行类中定义的Java程序代码，此阶段是执行<clinit>()方法的过程</li><li><clinit>()方法由编译器按语句在源文件中出现的顺序，依次自动收集类中所有的静态变量的赋值动作和静态代码块中的语句，并进行合并。</li><li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁，同步。如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。</li></ol><h1 id="四、反射相关方法的使用"><a href="#四、反射相关方法的使用" class="headerlink" title="四、反射相关方法的使用"></a>四、反射相关方法的使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">public</span> Integer id;<br>    <span class="hljs-keyword">private</span> String address;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(Integer id, String address)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(Integer id)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;编号为：&quot;</span>+id+<span class="hljs-string">&quot;的汽车开始运行&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restart</span><span class="hljs-params">(String address)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;原产地为：&quot;</span>+address+<span class="hljs-string">&quot;的汽车重启&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Car&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, address=&#x27;&quot;</span> + address + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class cls=Class.forName(<span class="hljs-string">&quot;base.reflection.pojo.Car&quot;</span>);<br><br>    <span class="hljs-comment">//无参构造获取car实例</span><br>    Object o=cls.newInstance();<br>    System.out.println(o);<br>    System.out.println(Integer.class);<br>    <span class="hljs-comment">//通过public修饰的构造器创建对象</span><br>    Constructor constructor=cls.getConstructor(Integer.class);<br>    Object o1=constructor.newInstance(<span class="hljs-number">126</span>);<br>    System.out.println(o1);<br>    <span class="hljs-comment">//通过private修饰的构造器创建对象</span><br>    Constructor constructor1=cls.getDeclaredConstructor(Integer.class,String.class);<br>    <span class="hljs-comment">//未设置为true，则不能修改或使用私有属性和方法（下同）</span><br>    constructor1.setAccessible(<span class="hljs-literal">true</span>);<br>    Object o2=constructor1.newInstance(<span class="hljs-number">100</span>,<span class="hljs-string">&quot;新西兰&quot;</span>);<br>    System.out.println(o2);<br><br><br>    <span class="hljs-comment">//修改o的public修饰的属性</span><br>    Field fieldId=cls.getField(<span class="hljs-string">&quot;id&quot;</span>);<br>    fieldId.set(o,<span class="hljs-number">123</span>);<br>    <span class="hljs-comment">//修改o的private修饰的属性</span><br>    Field fieldAddress=cls.getDeclaredField(<span class="hljs-string">&quot;address&quot;</span>);<br>    fieldAddress.setAccessible(<span class="hljs-literal">true</span>);<br>    fieldAddress.set(o,<span class="hljs-string">&quot;冰岛&quot;</span>);<br>    System.out.println(o);<br><br>    <span class="hljs-comment">//调用o的方法</span><br>    Method methodStart=cls.getMethod(<span class="hljs-string">&quot;start&quot;</span>,Integer.class);<br>    methodStart.invoke(o,<span class="hljs-number">6</span>);<br>    <span class="hljs-comment">//调用o的private的方法</span><br>    Method methodRestart=cls.getDeclaredMethod(<span class="hljs-string">&quot;restart&quot;</span>,String.class);<br>    methodRestart.setAccessible(<span class="hljs-literal">true</span>);<br>    methodRestart.invoke(o,<span class="hljs-string">&quot;英国&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>视频资料</strong>：<a href="https://www.bilibili.com/video/BV1g84y1F7df/?from=search&seid=12408684664800836462&spm_id_from=333.337.0.0&vd_source=8e40d0a91b994e176587f5593e189b6a">【韩顺平讲Java】Java反射专题</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云服务器安装Redis</title>
    <link href="/2022/10/25/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Redis/"/>
    <url>/2022/10/25/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="一、安装Redis"><a href="#一、安装Redis" class="headerlink" title="一、安装Redis"></a>一、安装Redis</h2><ol><li>从redis的官网下载redis的安装包，redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></li><li>将redis的安装包通过Xftp上传到云服务上，自己选择一个文件夹存放redis安装包并进行解压</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xzf redis-7.0.0.tar.gz<br></code></pre></td></tr></table></figure><p>解压后如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/image-20221020134406224.png" alt="image-20221020134406224"></p><ol start="3"><li>Redis是基于C语言编写的，需要安装Redis所需要的gcc依赖，使用如下命令安装依赖</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum install -y gcc tcl<br></code></pre></td></tr></table></figure><ol start="4"><li>进入解压后的redis目录,运行编译命令,redis默认的安装路径是在 <code>/usr/local/bin</code>目录下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">make &amp;&amp; make install<br></code></pre></td></tr></table></figure><h2 id="二、开启远程连接"><a href="#二、开启远程连接" class="headerlink" title="二、开启远程连接"></a>二、开启远程连接</h2><ol><li>先找到redis.conf文件，将文件中的bind 127.0.0.1 -::1注释，不然只允许127.0.0.1连接，如下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#bind 127.0.0.1 -::1</span><br></code></pre></td></tr></table></figure><blockquote><p>bind ip是将指定的ip设置为redis的对外开放地址</p></blockquote><ol start="2"><li>将daemonize no修改为damemonize yes，即可后台运行redis</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">daemonize <span class="hljs-built_in">yes</span> <br></code></pre></td></tr></table></figure><ol start="3"><li>查找 # requirepass foobared，将注释去掉，设置连接密码</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">requirepass</span> 连接密码<br></code></pre></td></tr></table></figure><ol start="4"><li>启动redis</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-server redis.conf<br></code></pre></td></tr></table></figure><ol start="5"><li>本地连接redis成功<br><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/image-20221020140807427.png" alt="image-20221020140807427"></li></ol>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
