<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>版本控制</title>
    <link href="/2023/07/09/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/07/09/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="一、版本管理的演变"><a href="#一、版本管理的演变" class="headerlink" title="一、版本管理的演变"></a>一、版本管理的演变</h1><h2 id="1-未出现版本控制"><a href="#1-未出现版本控制" class="headerlink" title="1. 未出现版本控制"></a>1. 未出现版本控制</h2><p>用目录拷贝区分不同版本，公共文件容易被覆盖，成员沟通成本高、效率低下</p><h2 id="2-集中式VCS"><a href="#2-集中式VCS" class="headerlink" title="2. 集中式VCS"></a>2. 集中式VCS</h2><p>有集中的版本管理服务器，具备文件版本管理和分支管理的能力，但是客户端必须时刻与服务器相连（本地只有一部分版本，只能通过服务器查询整个项目的情况）。如：CAS、SVN</p><p><img src="https://raw.githubusercontent.com/PursueMilk/img/main/img/202307091714274.png" alt="img"></p><h2 id="3-分布式VCS"><a href="#3-分布式VCS" class="headerlink" title="3. 分布式VCS"></a>3. 分布式VCS</h2><p>服务端和客户端都具有完整的版本库，查看历史版本等操作不需要访问服务器，比集中式VCS更能提高版本管理效率。如：Git等</p><p><img src="https://raw.githubusercontent.com/PursueMilk/img/main/img/202307091714280.png" alt="img"></p><p>Git、GitHub、GitLab的区别？</p><p>GitHub、GitLab都是基于Web的Git仓库，代码托管平台。Git是版本控制系统，是一种工具，用于代码的版本控制和存储。</p><p>相关资料：<a href="https://blog.cutepig.net/archives/amp/423">https://blog.cutepig.net/archives/amp/423</a></p><h1 id="二、Git相关知识"><a href="#二、Git相关知识" class="headerlink" title="二、Git相关知识"></a>二、Git相关知识</h1><h2 id="1-Git基础"><a href="#1-Git基础" class="headerlink" title="1. Git基础"></a>1. Git基础</h2><h3 id="1-1-Git的安装及配置"><a href="#1-1-Git的安装及配置" class="headerlink" title="1.1. Git的安装及配置"></a>1.1. Git的安装及配置</h3><ol><li>安装<a href="https://git-scm.com/downloads">Git</a>，安装好后<code> git --version</code> 查看git 的版本。</li><li>Git的相关设置：</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&#x27;your_name&#x27;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&#x27;your_email&#x27;</span><br></code></pre></td></tr></table></figure><p>通过以上命令设置全局用户名和邮箱，复查代码可以通知对应的提交人员</p><p>Git的配置范围（默认local，范围越小优先级越高）</p><p><code>git config --local</code> local：设置在当前仓库有效</p><p><code>git config --global</code>global：设置在该用户有效</p><p><code>git config --system</code>system：设置在多用户有效</p><p>查看Git的配置</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --list --范围(<span class="hljs-keyword">local</span>/<span class="hljs-keyword">global</span>/system)<br></code></pre></td></tr></table></figure><h3 id="1-2-Git的常用命令"><a href="#1-2-Git的常用命令" class="headerlink" title="1.2. Git的常用命令"></a>1.2. Git的常用命令</h3><ol><li>创建Git仓库</li></ol><p><code>git init</code>在当前文件初始化Git仓库</p><p><code>git init 文件夹名</code>在当前文件夹下创建该文件并初始化Git仓库</p><ol start="2"><li>查看状态</li></ol><p><code>git status</code> 查看文件的状态</p><ol start="3"><li>查看文件之间的差异</li></ol><p><code>git diff --cached xx</code>   查看暂存区的变化</p><p><code>git diff xx</code>  查看当前工作区和暂存区之间的差异</p><ol start="4"><li>提交更新</li></ol><p><code>git add filename</code> 将文件提交到暂存区</p><p><code>git add -u</code>  将已管理并且修改的文件都进行暂存</p><p><code>git commit -m &#39;&#39;</code> 提交暂存区中的文件</p><ol start="5"><li>删除文件</li></ol><p><code>git rm filename</code>  将删除对应的文件暂存到缓冲区（工作目录也会删除对应的文件）</p><p><code>git rm --cached filename</code> 只从暂存区移除，工作区不删除</p><ol start="6"><li>修改文件名</li></ol><p><code>mv filename newFilename</code><br><code>git rm filename</code><br><code>git add newFilename</code></p><p>总结：<code>git mv filename newFilename</code></p><ol start="7"><li>查看提交历史</li></ol><p><code>git log </code> 按时间顺序列出所有提交，最近的在最上面</p><p><code>git log --online</code> 查看简洁信息（每个提交信息在一行中显示）</p><p><code>git log -n4</code> 只查看前几次提交信息</p><p><code>git log --all</code> 查看所有分支的日志</p><p><code>git log --all --graph</code> 图形化形式查看所有分支的日志</p><ol start="8"><li>提交区操作</li></ol><p><code>git commit --amend</code>  对最近一次提交信息进行修改或者将第二次提交替代第一次提交</p><p><code>git rebase -i parentid</code>     修改以前提交的commit信息，将需要修改的信息修改为 r</p><p><code>git rebase -i parentid</code>      修改以前提交的信息，将需要修改的信息修改为 s</p><p><code>git reset --hard commitid</code> 将之前提交的commit都清除，所有文件回到这个commit提交的内容</p><ol start="9"><li>暂存区操作</li></ol><p><code>git reset head (filename)</code> 清空暂存区，可以指定文件</p><p><code>git checkout filename</code>  将工作区恢复成最近一次提交内容</p><p><code>git chechout commitID </code>切换到该次提交（头指针分离）</p><ol start="10"><li>远程仓库</li></ol><p><code>git remote -v</code> 显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL </p><p><code>git remote add name url</code> 添加一个新的远程 Git 仓库</p><p><code>git remote rename oldname newname</code> 远程仓库重命名</p><p><code>git remote remove name</code> 删除远程仓库，其相关分支以及配置也会被删除</p><p><code>git fetch remotename branchname</code> 拉取远端分支</p><p><code>git push remotename branch</code> 向远端推送分支</p><p><code>git push &lt;remote&gt; localbranch:refs/for/remotebranch  </code> 向远端推送分支（需要进行code review）</p><blockquote><p>git push origin HEAD:refs&#x2F;for&#x2F;remotebranch</p></blockquote><h2 id="2-Git分支"><a href="#2-Git分支" class="headerlink" title="2. Git分支"></a>2. Git分支</h2><p>使用分支可以把个人工作从开发主线上分离开来，以免影响开发主线。创建分支只是创建了一个可移动的新指针，通过head指针就可以知道当前处于哪个分支上。</p><p><img src="https://raw.githubusercontent.com/PursueMilk/img/main/img/202307091714266.png" alt="img"></p><ol><li>分支命令</li></ol><p><code>git branch</code> 分支列表</p><p><code>git branch name</code> 创建分支</p><p><code>git branch -D name</code>  删除分支</p><p><code>git checkout (-b) name</code> 切换分支（创建并切换分支）</p><p><code>git branch --merged</code> 查看已合并的分支</p><p><code>git branch --no-merged</code> 查看未合并的分支</p><ol start="2"><li>远程分支</li></ol><p>远程分支以 remotename&#x2F;branch 命名，如 origin&#x2F;master </p><p><code>git remote show name</code> 查看远程分支信息</p><p><code>git fetch remotename branchname</code> 同步远程分支数据，不写远程仓库默认所有的，不写分支默认远程仓库所有分支</p><p><code>git merge branch</code> 合并冲突</p><p><code>git pull remotename remotebranch:localbranch</code> 从远程仓库拉取数据并合并，省略本地分支则默认当前所在分支</p><p><code>git push remotename localbranch:remotebranch</code> 将数据推送到远程分支上</p><ol start="3"><li>跟踪分支</li></ol><p>跟踪分支是与远程分支有直接关系的本地分支。</p><p><code>git checkout -b localbranch remotename/branch</code> 创建跟踪分支（起点在remotename&#x2F;branch上的分支）</p><p><code>git branch -u remotename/branch</code> 设置跟踪分支</p><p><code>git branch -vv</code> 可查看本地分支跟踪的远程分支</p><ol start="4"><li>删除远程分支</li></ol><p><code>git push &lt;remote&gt; --delete branch</code> 删除远程分支</p><ol start="5"><li>变基</li></ol><p>使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，这个操作就叫变基。</p><p><code>git rebase branch</code>  以该分支为基底 </p><ol start="6"><li>缓存</li></ol><p><code>git stash</code> 将当前改动暂存 </p><p><code>git stash list</code> 查看暂存列表</p><p><code>git stash pop</code>  弹出第一个暂存</p><p><code>git stash apply</code> 应用第一个暂存，不会从暂存列表中移除</p><p><code>git stash clear</code> 清除暂存列表 </p><ol start="7"><li>禁止行为</li></ol><p><code>git push -f</code>  强制推送</p><p>不要对集成分支进行变基</p><ol start="8"><li>实践</li></ol><p><code>git pull origin master:master</code> </p><p><code>git merge --no-ff branchname</code></p><p><code>git commit --amend</code></p><p><code>git push origin HEAD:refs/for/master</code></p><blockquote><p>–no-ff 关闭快进模式，产生一个新的提交</p></blockquote><h2 id="3-GitHub"><a href="#3-GitHub" class="headerlink" title="3. GitHub"></a>3. GitHub</h2><ol><li><code>in:readme</code> 在readme中搜索</li></ol>]]></content>
    
    
    <categories>
      
      <category>版本控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>版本控制</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2023/07/09/Linux/"/>
    <url>/2023/07/09/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Linux概述"><a href="#一、Linux概述" class="headerlink" title="一、Linux概述"></a>一、Linux概述</h1><h2 id="1-1-什么是Linux？"><a href="#1-1-什么是Linux？" class="headerlink" title="1.1 什么是Linux？"></a>1.1 什么是Linux？</h2><ol><li>一种是Linux编写的开源操作系统的内核</li><li>一种广义的操作系统</li></ol><blockquote><p>Linux一般用作服务器，它不需要客户端那样华丽的界面，所以它一般以命令行形式进行操作。</p></blockquote><h2 id="1-2-Linux的版本"><a href="#1-2-Linux的版本" class="headerlink" title="1.2 Linux的版本"></a>1.2 Linux的版本</h2><ol><li>内核版本：Linux内核分为三个部分主版本号、次版本号、末版本号，次版本号是奇数为开发版，偶数为稳定版。</li><li>发行版：Linux是开源的，国内厂商会基于Linux内核进行开发，如：redhat(商用)、fedora(免费)、centos(基于redhat编译的免费版)</li></ol><blockquote><p>一般我们使用的都是centos，使用ssh连接远程服务器</p></blockquote><h2 id="1-3-Linux常见目录"><a href="#1-3-Linux常见目录" class="headerlink" title="1.3 Linux常见目录"></a>1.3 Linux常见目录</h2><ul><li>&#x2F; 根目录</li><li>&#x2F;root  root用户的家目录</li><li>&#x2F;home&#x2F;username 普通用户的家目录</li><li>&#x2F;etc 配置文件目录</li><li>&#x2F;bin 命令目录</li><li>&#x2F;sbin 管理命令目录</li><li>&#x2F;user&#x2F;bin &#x2F;user&#x2F;sbin 系统预装的其他命令</li></ul><h1 id="二、系统操作"><a href="#二、系统操作" class="headerlink" title="二、系统操作"></a>二、系统操作</h1><h2 id="2-1-帮助命令"><a href="#2-1-帮助命令" class="headerlink" title="2.1 帮助命令"></a>2.1 帮助命令</h2><ol><li><p><strong>man 帮助命令</strong></p><p>man [命令名称] </p></li><li><p><strong>help 帮助命令</strong></p><p>help cd[命令]内部命令使用 help 帮助</p><p>ls –help      外部命令使用 help 帮助</p></li></ol><blockquote><p>shell（命令解释器）自带的为内部命令，不自带的为外部命令，type 命令 查看该命令为内部命令或外部命令</p></blockquote><ol start="3"><li><p><strong>info 帮助</strong></p><p>info [命令]</p></li></ol><blockquote><p>info比 help 更详细，作为 help 的补充，提示全为英文版</p></blockquote><h2 id="2-2-文件管理"><a href="#2-2-文件管理" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h2><h3 id="2-2-1-文件查看"><a href="#2-2-1-文件查看" class="headerlink" title="2.2.1 文件查看"></a>2.2.1 文件查看</h3><ol><li><p><strong>显示当前位置</strong></p><p>pwd   </p></li><li><p><strong>更改当前的操作目录</strong></p><p>cd</p></li><li><p><strong>查看当前目录下的文件</strong></p><p>ls  [选项，选项…]   [文件名…]  </p><p>常用参数：</p><ul><li>-l 长格式显示文件（显示更多的文件信息，如：时间、权限、作者等）</li><li>-a 显示隐藏文件</li><li>-r 逆序显示</li><li>-t 按照时间顺序显示</li><li>-R 递归显示</li><li>-h 文件大小以MB显示</li></ul></li></ol><h3 id="2-2-2-目录管理"><a href="#2-2-2-目录管理" class="headerlink" title="2.2.2 目录管理"></a>2.2.2 目录管理</h3><ol><li><p><strong>创建目录</strong></p><p>mkdir   [参数]   [目录名]</p><p>常用参数：</p><ul><li>-p  建立多级目录</li></ul></li><li><p><strong>删除空目录</strong></p><p>rmdir    [目录名]</p></li><li><p><strong>创建文件</strong></p><p>touch   [文件名]</p></li><li><p><strong>删除文件</strong></p><p>rm [参数] [文件名]</p><p>常用参数</p><ul><li>-r 删除目录（包括目录下所有文件）</li><li>-f 删除文件不进行提示</li></ul></li><li><p><strong>复制文件或目录</strong></p><p>cp   源文件   目的文件    </p><p>常用参数</p><ul><li>-r 复制目录</li><li>-p 保留用户、权限、时间等文件属性</li></ul></li><li><p><strong>移动文件（重命名）</strong></p><p>mv  [选项]  源文件  目标文件</p><p>常用参数</p><ul><li>-r 移动目录</li></ul></li></ol><h3 id="2-2-3-文本查看"><a href="#2-2-3-文本查看" class="headerlink" title="2.2.3 文本查看"></a>2.2.3 文本查看</h3><ol><li><p><strong>文本内容显示到终端</strong></p><p>cat[文件名]</p></li><li><p><strong>查看文件开头</strong></p><p>head[参数][文件名]</p><p>常用参数</p><ul><li>-nn行（默认10）</li></ul></li><li><p><strong>查看文件结尾</strong></p><p>tail[参数][文件名]</p><p>常用参数</p><ul><li>-f文件内容更新后，显示信息同步更新</li><li>-n   n行（默认10）</li></ul></li><li><p><strong>统计文件内同信息</strong></p><p>wc[参数][文件名]</p><p>常用参数</p><ul><li>-l   统计文件的行数</li></ul></li></ol><h2 id="2-3-打包和压缩"><a href="#2-3-打包和压缩" class="headerlink" title="2.3 打包和压缩"></a>2.3 打包和压缩</h2><ol><li><p><strong>打包</strong></p><p>tar [参数] [打包的文件名] [打包的文件夹]</p><p>常用参数</p><ul><li>c 打包</li><li>x 解包</li><li>f 指定操作类型为文件</li><li>v 显示详细信息</li><li>z gzip压缩</li><li>j bzip2压缩</li></ul></li><li><p><strong>解压</strong></p><p>tar -vxf 文件名</p></li></ol><blockquote><p>参数添加不同的压缩类型参数，解压不同类型的压缩文件，如 tar -vzxf filename 解压gzip压缩</p></blockquote><h2 id="2-4-文本编辑器"><a href="#2-4-文本编辑器" class="headerlink" title="2.4 文本编辑器"></a>2.4 文本编辑器</h2><ol><li><p><strong>查看文档</strong></p><p>vim 文件名</p></li><li><p><strong>输入a、 i、o 等进入编辑模式</strong></p></li><li><p><strong>剪切</strong></p><p>[n]dd   剪切当前行开始的n行</p></li><li><p><strong>复制</strong></p><p>[n]yy   复制当前行开始的n行</p><p>[n]p     粘贴n次所复制的</p></li><li><p><strong>删除</strong></p><p>[n]x      删除当行,或者删除当前行开始的n行</p></li><li><p><strong>关闭高亮</strong></p><p>:set nohl</p></li><li><p><strong>查看行数</strong></p><p>:set [no]nu</p></li></ol><blockquote><p>设置永久生效则需要去配置文件（&#x2F;etc&#x2F;vimrc）中添加 set nu的配置</p></blockquote><ol start="8"><li><p><strong>撤销命令</strong></p><p>:[n]u   撤销上[n]次的操作</p></li><li><p><strong>查找命令</strong></p><p>&#x2F;字符</p></li></ol><blockquote><p>n向下移动查找 shift n向上移动查找</p></blockquote><ol start="10"><li><p><strong>替换</strong></p><p>:s&#x2F;old&#x2F;new  默认表示所在行范围进行替换</p><p>:%s&#x2F;old&#x2F;new&#x2F;g 整个文件范围替换使用</p></li></ol><blockquote><p>%代表整个文件范围，g 表示全局（多次替换）</p></blockquote><ol start="11"><li><p><strong>临时命令</strong></p><p>:!  命令</p></li></ol><blockquote><p>! ipconfig ，表示临时查看命令</p></blockquote><ol start="12"><li><p><strong>文件保存退出</strong></p><p>:w filename 保存到指定文件名中，不接文件名表示保存到原始文件当中</p><p>:q 退出</p><p>:q! 强制退出</p><p>:wq! 强制写入退出</p></li><li><p><strong>可视模式</strong></p><p>v 字符可视模式，以字符为单位选择</p><p>V 行可视模式，以行为单位选择</p><p>ctrl+v 块可视模式，光标选中多行后按大写I，[按d进行删除]然后输入内容，再按两次ESC，即可批量操作</p></li></ol><h2 id="2-5-用户和用户组管理"><a href="#2-5-用户和用户组管理" class="headerlink" title="2.5 用户和用户组管理"></a>2.5 用户和用户组管理</h2><ol><li><p><strong>添加用户</strong></p><p>useradd username</p></li></ol><blockquote><p>id username 可以查看用户相关信息</p></blockquote><ol start="2"><li><p><strong>删除用户</strong></p><p>userdel [参数] username</p><p>常用参数</p><ul><li>-r 删除用户的家目录</li></ul></li><li><p><strong>修改用户密码</strong></p><p>passwd username</p></li><li><p><strong>修改用户属性</strong> </p><p>usermode -g groupname username   将用户加入到该组</p></li><li><p><strong>切换用户</strong></p><p>su - username</p></li></ol><blockquote><p>-代表切换到该用户所在的目录，visudo 设置需要使用 sudo 的用户组以及相关命令，sudo 命令以其他用户身份执行命令</p></blockquote><ol start="6"><li><p><strong>添加组</strong></p><p>groupadd groupname</p></li><li><p><strong>删除组</strong></p><p>groupdel groupname</p></li></ol><h2 id="2-6-文件与目录权限"><a href="#2-6-文件与目录权限" class="headerlink" title="2.6 文件与目录权限"></a>2.6 文件与目录权限</h2><p><img src="https://raw.githubusercontent.com/PursueMilk/img/main/img/202307091546564.png" alt="20230708224023"></p><ol><li><p>文件类型：- 普通文件、d 目录 、b 特殊文件、c 字符特殊文件、l 符号连接、f 命名管道、s 套接字文件</p></li><li><p>文件权限：分为属主、组、其他用户权限，权限表示 r 4 读、w 2 写、x 1 执行</p></li><li><p>目录权限：x 进入目录、rx 显示目录内的文件名、wx 修改目录内的文件名</p></li><li><p>修改权限</p><p>chmod 权限 filename</p><p>chown user:group filename 修改所属主、属组</p></li></ol><h1 id="三、系统管理"><a href="#三、系统管理" class="headerlink" title="三、系统管理"></a>三、系统管理</h1><h2 id="3-1-网络管理"><a href="#3-1-网络管理" class="headerlink" title="3.1 网络管理"></a>3.1 网络管理</h2><ol><li><p><strong>查看网卡信息</strong></p><p>ifconfig</p></li></ol><blockquote><p>inet代表 ip 地址</p></blockquote><ol start="2"><li><p><strong>查看网关</strong></p><p>route -n</p></li></ol><blockquote><p>-n不解析域名</p></blockquote><ol start="3"><li><p><strong>测试网络连通性</strong></p><p>ping ipaddress</p></li></ol><h2 id="3-2-软件管理包"><a href="#3-2-软件管理包" class="headerlink" title="3.2 软件管理包"></a>3.2 软件管理包</h2><h3 id="3-2-1-rpm软件包管理器"><a href="#3-2-1-rpm软件包管理器" class="headerlink" title="3.2.1 rpm软件包管理器"></a>3.2.1 rpm软件包管理器</h3><ol><li><p><strong>查看已安装的rpm软件包</strong></p><p>rpm -qa | grep more</p><p>rpm -q 包名</p></li><li><p><strong>安装rpm软件包</strong></p><p>rpm -i 包名</p></li><li><p><strong>卸载安装的rpm软件包</strong></p><p>rpm -e 包名</p></li></ol><h3 id="3-2-2-yum包管理工具"><a href="#3-2-2-yum包管理工具" class="headerlink" title="3.2.2 yum包管理工具"></a>3.2.2 yum包管理工具</h3><ol><li><p><strong>安装软件包</strong></p><p>yum install 包名</p></li><li><p><strong>卸载软件包</strong></p><p>yum remove 包名</p></li><li><p><strong>更新软件包</strong></p><p>yum update 包名 (不指定则更新所有软件包)</p></li></ol><blockquote><p>rpm需要自己解决依赖关系，软件包的来源不可靠，而yum是一个基于rpm的软件包管理器，会自动解决依赖性问题，使用yum包管理工具时需要修改yum镜像</p></blockquote><h3 id="3-2-3-源代码编译软件包"><a href="#3-2-3-源代码编译软件包" class="headerlink" title="3.2.3 源代码编译软件包"></a>3.2.3 源代码编译软件包</h3><ol><li><p><strong>下载源代码软件包</strong></p><p>wget 软件包地址</p></li><li><p><strong>解压软件包</strong></p><p>tar zxf 软件包</p></li><li><p><strong>安装源代码软件包</strong></p><p>.&#x2F;configure –prefix&#x3D;&#x2F;user&#x2F;local 指定安装位置</p><p>make 编译</p><p>make install 安装</p></li></ol><h2 id="3-3-进程管理"><a href="#3-3-进程管理" class="headerlink" title="3.3 进程管理"></a>3.3 进程管理</h2><ol><li><p><strong>ps查看进程</strong></p><p>ps [参数]</p><p>常见参数</p><ul><li>-e 显示所有进程</li><li>-f 显示完整格式</li></ul></li><li><p><strong>top查看进程</strong></p><p>top [参数]</p><p>常见参数</p><ul><li>-p进程号  指定进程</li></ul></li></ol><blockquote><p>pstree以树状图的方式展现进程之间的派生关系</p></blockquote><ol start="3"><li><p><strong>结束进程</strong></p><p>kill -9 PID</p></li></ol><h2 id="3-4-内存与磁盘管理"><a href="#3-4-内存与磁盘管理" class="headerlink" title="3.4 内存与磁盘管理"></a>3.4 内存与磁盘管理</h2><ol><li><p><strong>查看内存使用率和内存大小</strong></p><p>free [参数]</p></li></ol><blockquote><p>top 也可以查看</p></blockquote><ol start="2"><li><p>磁盘使用率和分区</p><p>fdisk [参数]</p></li></ol><h1 id="四、Shell"><a href="#四、Shell" class="headerlink" title="四、Shell"></a>四、Shell</h1><p>shell是一个命令解释器，接受命令解释给内核再将结果返回到终端上，centos7终端的Shell是bash</p><h2 id="4-1-Shell脚本"><a href="#4-1-Shell脚本" class="headerlink" title="4.1 Shell脚本"></a>4.1 Shell脚本</h2><p><strong>脚本执行</strong></p><ol><li>bash xx.sh 执行脚本</li><li>.&#x2F;xx.sh 执行脚本</li><li>source .&#x2F;xx.sh </li><li>. xx.sh</li></ol><p>1、2会产生新的子进程运行脚本，3、4不会产生子进程运行脚本会对当前环境产生影响</p><p><strong>管道与管道符</strong></p><p>管道符为 ｜，将前一个命令执行的结果传递给后一个命令</p><h1 id="五、文本操作与服务管理"><a href="#五、文本操作与服务管理" class="headerlink" title="五、文本操作与服务管理"></a>五、文本操作与服务管理</h1><ol><li><p><strong>查找</strong></p><p>locate</p></li><li><p><strong>文本替换</strong></p><p>sed  参数  filename</p></li></ol><blockquote><p>sed -i ‘s&#x2F;book&#x2F;books&#x2F;g’ file  匹配file文件中每一行的所有book替换为books</p></blockquote><ol start="3"><li><p><strong>远程连接</strong></p><p>ssh [-p 端口] username@远程ip</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式</title>
    <link href="/2023/03/26/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/03/26/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>顾名思义，工厂模式是用工厂方法代替 new 操作的一种模式。工厂模式可以分为三种类型：简单工厂、工厂方法、抽象工厂。</p><h2 id="1-1-简单工厂"><a href="#1-1-简单工厂" class="headerlink" title="1.1 简单工厂"></a>1.1 简单工厂</h2><p>定义<strong>一个</strong>工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。</p><p><strong>适用场景</strong></p><ol><li>由于只有一个工厂类，类的创建不能过于复杂或者创建的类过多</li><li>使用者不关系类的创建过程</li></ol><p><strong>实例</strong>：我们根据配置文件中不同的序列化类型，选择不同的序列化的实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 序列化接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RpcSerialization</span> &#123;<br><br>    &lt;T&gt; <span class="hljs-type">byte</span>[] serialize(T obj) <span class="hljs-keyword">throws</span> IOException;<br><br>    &lt;T&gt; T <span class="hljs-title function_">deserialize</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data, Class&lt;T&gt; clz)</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 序列化工厂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializationFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RpcSerialization <span class="hljs-title function_">getRpcSerialization</span><span class="hljs-params">(SerializationTypeEnum typeEnum)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (typeEnum) &#123;<br>            <span class="hljs-keyword">case</span> JSON:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonSerialization</span>();<br>            <span class="hljs-keyword">case</span> PROTOSTUFF:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtostuffSerializer</span>();<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;serialization type is illegal&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 序列化实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonSerialization</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RpcSerialization</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-type">byte</span>[] serialize(T obj) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 序列化</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">deserialize</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data, Class&lt;T&gt; clz)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 反序列化</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProtostuffSerializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RpcSerialization</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-type">byte</span>[] serialize(T obj) <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">// 序列化</span><br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">deserialize</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data, Class&lt;T&gt; clz)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">// 反序列化</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-工厂方法"><a href="#1-2-工厂方法" class="headerlink" title="1.2 工厂方法"></a>1.2 工厂方法</h2><p> 在工厂方法模式中，针对不同的对象提供不同的工厂，即每个对象都有一个与之对应的工厂。</p><p><strong>适用场景</strong></p><ol><li>对象创建的逻辑较为复杂，可以通过子类工厂创建对应的子类实例</li><li>使用者不需要了解对象的创建过程</li></ol><blockquote><p>工厂方法和简单工厂的区别：</p><ol><li>简单工厂只能算一种编程习惯，而不是一种设计模式。而工厂方法算一种设计模式</li><li>工厂方法为每个对象都创建一个工厂，而简单工厂只创建一个工厂</li><li>工厂方法中每个工厂都继承了创建对象的接口</li></ol></blockquote><p><strong>实例</strong>：通过不同的文件后缀名(yaml、xml、json)，创建不同的解析对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>    <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>        <span class="hljs-comment">// 获取文件后缀名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br>        <span class="hljs-comment">// 获取对应的实例工厂</span><br>        <span class="hljs-type">IRuleConfigParserFactory</span> <span class="hljs-variable">parserFactory</span> <span class="hljs-operator">=</span> RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);<br>        <span class="hljs-keyword">if</span> (parserFactory == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<span class="hljs-string">&quot;Rule config file format is not support!&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 创建对应的实例</span><br>        <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> parserFactory.createParser();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>        <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>        <span class="hljs-keyword">return</span> ruleConfig;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 因为工厂类只包含方法，不包含成员变量，完全可以复用，</span><br><span class="hljs-comment">// 不需要每次都创建新的工厂类对象，所以，工厂方法模式的思路更加合适</span><br><span class="hljs-comment">// 工厂的工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigParserFactoryMap</span> &#123; <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        cachedFactories.put(<span class="hljs-string">&quot;json&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParserFactory</span>());<br>        cachedFactories.put(<span class="hljs-string">&quot;xml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParserFactory</span>());<br>        cachedFactories.put(<span class="hljs-string">&quot;yaml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParserFactory</span>());<br>        cachedFactories.put(<span class="hljs-string">&quot;properties&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParserFactory</span>())<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IRuleConfigParserFactory <span class="hljs-title function_">getParserFactory</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span> || type.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">IRuleConfigParserFactory</span> <span class="hljs-variable">parserFactory</span> <span class="hljs-operator">=</span> cachedFactories.get(type.toLowerCase());<br>        <span class="hljs-keyword">return</span> parserFactory;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建实例的接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>    IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 解析器工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YamlRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertiesRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-抽象工厂"><a href="#1-3-抽象工厂" class="headerlink" title="1.3 抽象工厂"></a>1.3 抽象工厂</h2><p>抽象工厂中可以让一个工厂负责创建多个不同类型的对象</p><p><strong>适用场景</strong></p><ol><li>工厂类中需要创建一组对象</li><li>使用者不关心对象的创建过程</li></ol><p><strong>实例</strong>：现在需要做一款跨平台的游戏，需要兼容Android，Ios，Wp三个移动操作系统，该游戏针对每个系统都设计了一套操作控制器（OperationController）和界面控制器（UIController）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WpFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SystemFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> OperationController <span class="hljs-title function_">createOperationController</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WpOperationController</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UIController <span class="hljs-title function_">createInterfaceController</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WpUIController</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他代码和工厂方法的代码类似</p><blockquote><p>工厂方法和抽象工厂的区别？</p><ol><li>抽象工厂中的子类工厂可以创建一组对象，而工厂方法中的子类工厂只能创建一个对象</li></ol></blockquote><h1 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h1><p>当对象的创建逻辑比较复杂，是一个大工程的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。  </p><p><strong>比较复杂的场景</strong></p><ol><li>存在 if-else 分支判断，动态的根据不同的类型创建不同的对象，这时候我们可以考虑将一大堆 if-else 抽离封装到一个工厂类中。</li><li>单个对象的创建比较复杂，如：需要组合其他对象、做各种初始化操作，这时候我们也可以考虑将其封装到工厂类中。</li></ol><p><strong>好处</strong></p><ol><li>封装后，创建逻辑对调用者更加透明，不需要了解对象复杂的创建过程</li><li>代码复用：创建代码抽离到独立的工厂类之后可以复用</li><li>控制复杂度：将创建代码抽离，让本来的函数或类职责单一、代码更加简洁</li></ol><p><strong>实例</strong>：Java中的 Calender、DateFormat、Excutors，Spring中的 FactoryBean 等</p><p><strong>参考资料</strong></p><ol><li><a href="https://juejin.cn/post/6992716383893061663">三分钟快速了解Spring中的工厂模式 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/6844903474639929357">工厂模式</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>创建型</tag>
      
      <tag>工厂模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2023/02/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>单例设计模式：一个类只允许创建一个对象或者实例（唯一的范围：进程），那这个类就是一个单例类，这种设计模式即为单例设计模式。</p><blockquote><p>为什么需要单例模式 ？</p><p>1、用于标识全局唯一的类（配置类、连接池类、ID生成器）   2、解决资源访问冲突的问题 </p><p>为什么不用静态方法而用单例模式？</p><p>两个都能实现我们加载的目的，静态方法基于对象的，单例模式是面向对象的。一个方法和所在的实例对象无关，那么它可以为静态方法。当方法与实例有关，但是在创建类时又只需要一份实例，则需要单例模式。（如电商中的类包含一些配置和属性并且是公共的，所以只需要一份就可以了）</p></blockquote><h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><p><strong>需要注意的点</strong>：</p><ul><li>构造函数需要被 private 访问修饰符修饰，避免外部通过 new 关键字创建实例</li><li>对象创建时的线程安全问题</li><li>是否需要延时加载</li><li>考虑 getInstance() 性能是否高（是否加锁）</li></ul><h2 id="2-1-饿汉式"><a href="#2-1-饿汉式" class="headerlink" title="2.1 饿汉式"></a>2.1 饿汉式</h2><p> instance 静态实例在类加载时已经创建并初始化好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 创建实例对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">// private修饰，构造器私有化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br><span class="hljs-comment">// 静态方法获取实例对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-懒汉式"><a href="#2-2-懒汉式" class="headerlink" title="2.2 懒汉式"></a>2.2 懒汉式</h2><p>相比于饿汉式，懒汉式的优势是支持延迟加载（当真正需要实例时，创建实例），懒汉式需要在方法上进行加锁（不加锁会出现并发问题），并发度为 1 ，如果频繁的用到这个单例，就会频繁加锁和释放锁等问题，这种方式则不可取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 判断实例对象是否创建</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 未创建则创建对象</span><br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-双重检测"><a href="#2-3-双重检测" class="headerlink" title="2.3 双重检测"></a>2.3 双重检测</h2><p>懒汉式的问题在于性能问题，不支持高并发问题。通过双重检测，只要 instance 被创建后，再调用 getInstance() 函数不会进入锁逻辑中，解决了懒汉式并发度低的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 判断实例对象是否创建</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 未创建则创建对象</span><br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于实例变量需要使用 volatile 关键字修饰，原因：创建一个对象分为三步：1. 分配内存空间   2. 初始化内存空间   3. 将内存地址赋值给变量，由于指令重排可能顺序变为：1—&gt; 3 —&gt; 2 ，导致一个线程拿到未初始化的对象，所以需要加 volatile 禁止指令重排，并且可以保证多个线程间该对象的准确性。</p></blockquote><h2 id="2-4-静态内部类"><a href="#2-4-静态内部类" class="headerlink" title="2.4 静态内部类"></a>2.4 静态内部类</h2><p>利用 Java 的静态内部类，当外部类 IdGenerator 被加载时，并不会创建 Singleton 实例对象，只有当调用 getInstance() 方法时，IdGenerator 会被创建实例，实例创建过程的线程安全性，由 JVM 保证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IdGenerator</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Singleton.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-枚举"><a href="#2-5-枚举" class="headerlink" title="2.5 枚举"></a>2.5 枚举</h2><p>通过 Java 枚举本身的性质，保证了实例的线程安全性和实例的唯一性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、存在的问题"><a href="#三、存在的问题" class="headerlink" title="三、存在的问题"></a>三、存在的问题</h1><ol><li>对OOP(封装、抽象、继承、多态)特性不友好</li></ol><p>单例模式违背了基于接口而非实现的设计原则（当需要两个独立的ID生成器时，就会产生较大的变动）</p><ol start="2"><li><p>单例会隐藏类之间的依赖关系</p></li><li><p>对扩展不友好（当代码中需要多个实例时，代码改动较大）</p></li><li><p>单例不支持有参数的构造函数</p></li></ol><p>要解决以上问题，可以通过工程模式、IOC容器、程序员自己保证来解决。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>创建型</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的排序算法</title>
    <link href="/2023/02/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2023/02/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h1><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p><p><img src="https://raw.githubusercontent.com/PursueMilk/img/main/img/202302112150635.png" alt="image-20230211215024466"></p><p><strong>优化</strong>：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。</p><p>空间复杂度：O(1)</p><p>时间复杂度：最好：O(n)，最坏：O(n^2^)，平均：O(n^2^)</p><p><strong>稳定</strong>的排序算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 循环 n-1 次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 终点为 n-i-1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-comment">// 比较相邻的数大小，将大的数往后移</span><br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>                arr[j] = arr[j + <span class="hljs-number">1</span>];<br>                arr[j + <span class="hljs-number">1</span>] = temp;<br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 本次循环未交换元素则退出</span><br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、插入排序"><a href="#二、插入排序" class="headerlink" title="二、插入排序"></a>二、插入排序</h1><p>将数组中的数据分为两个区间，<strong>已排序区间</strong>和<strong>未排序区间</strong>。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，排序结束。  </p><p><img src="https://raw.githubusercontent.com/PursueMilk/img/main/img/202302112156449.png" alt="image-20230211215645215"></p><p>空间复杂度：O(1)</p><p>时间复杂度：最好：O(n)，最坏：O(n^2^)，平均：O(n^2^)</p><p><strong>稳定</strong>的排序算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 未排序数组中第一个值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> arr[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-comment">// 比较值的大小</span><br>            <span class="hljs-keyword">if</span> (value &lt; arr[j]) &#123;<br>                arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        arr[j + <span class="hljs-number">1</span>] = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、选择排序"><a href="#三、选择排序" class="headerlink" title="三、选择排序"></a>三、选择排序</h1><p>选择排序也分为已排序区间和未排序区间，每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><p><img src="https://raw.githubusercontent.com/PursueMilk/img/main/img/202302112211235.png" alt="image-20230211221127129"></p><p>空间复杂度：O(1)</p><p>时间复杂度：最好：O(n^2^)，最坏：O(n^2^)，平均：O(n^2^)</p><p><strong>不稳定</strong>的排序算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">//寻找最小元素的下标</span><br>            <span class="hljs-keyword">if</span> (arr[index] &gt; arr[j]) &#123;<br>                index = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//进行交换</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[index];<br>        arr[index] = arr[i];<br>        arr[i] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小总结</strong></p><p>以上这三种排序算法（时间复杂度都为 O(n^2^) ），实现代码都非常简单，对于小规模数据的排序，用起来非常高效。但是在大规模数据排序的时候，这个时间复杂度还是稍微有点高。</p><h1 id="四、归并排序"><a href="#四、归并排序" class="headerlink" title="四、归并排序"></a>四、归并排序</h1><p>归并排序的核心思想：如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><p>归并排序使用的就是分治思想（分治是一种解决问题的处理思想，递归是一种编程技巧）。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。  </p><p><img src="https://raw.githubusercontent.com/PursueMilk/img/main/img/202302112225604.png" alt="image-20230211222528403"></p><p>空间复杂度：O(n)</p><p>时间复杂度：最好：O(nlogn)，最坏：O(nlogn)，平均：O(nlogn)</p><p><strong>稳定</strong>的排序算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//归并排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> n)</span> &#123;<br>    merge_sort_c(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge_sort_c</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-comment">//判断左右边界</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//取中点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//分治</span><br>    merge_sort_c(arr, l, mid);<br>    merge_sort_c(arr, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-comment">//当左右数组变为有序后再合并</span><br>    merge(arr, l, mid, r);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-comment">//定义一个数组</span><br>    <span class="hljs-type">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[r - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//左右数组比较大小，将元素添加到temp数组中</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) &#123;<br>            temp[k++] = arr[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            temp[k++] = arr[j++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//将剩余的元素添加到temp数组中</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>        temp[k++] = arr[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &lt;= r) &#123;<br>        temp[k++] = arr[j++];<br>    &#125;<br>    <span class="hljs-comment">//再将已排序的元素赋值给原数组</span><br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; temp.length; k++) &#123;<br>        arr[l + k] = temp[k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="五、快速排序"><a href="#五、快速排序" class="headerlink" title="五、快速排序"></a>五、快速排序</h1><p>快排的思想：</p><ol><li><p>如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r之间的任意一个数据作为 pivot（分区点）。</p></li><li><p>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。  </p></li><li><p>根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。</p></li></ol><p><img src="https://raw.githubusercontent.com/PursueMilk/img/main/img/202302142020438.png" alt="image-20230214202037253"></p><p>空间复杂度：O(1)</p><p>时间复杂度：最好：O(nlogn)，最坏：O(n^2^)，平均：O(nlogn)</p><p><strong>不稳定</strong>的排序算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//快排</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> n)</span> &#123;<br>    quickSortInternally(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSortInternally</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> r;<br>    <span class="hljs-comment">//基准位</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-comment">//左边大于基准位</span><br>        <span class="hljs-keyword">while</span> (j &gt; i &amp;&amp; arr[j] &gt;= temp) &#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">//右边小于等于基准位</span><br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= temp) &#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>            <span class="hljs-comment">//将左右不符合条件的数交换</span><br>            swap(arr, i, j);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//将基准数移到 i 和 j 相等的位置</span><br>    arr[l] = arr[i];<br>    arr[i] = temp;<br>    <span class="hljs-comment">//排序右数组</span><br>    quickSortInternally(arr, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//排序左数组</span><br>    quickSortInternally(arr, i + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="六、堆排"><a href="#六、堆排" class="headerlink" title="六、堆排"></a>六、堆排</h1><p>堆排序是一种原地的、时间复杂度为O(nlogn)的排序算法。  </p><p>堆的要求：</p><ul><li><p>堆必须是一个完全二叉树。（完全二叉树即除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列）</p></li><li><p>堆中的每个节点的值必须大于等于（或者小于等于）其子树中每个节点的值。</p></li></ul><blockquote><p>大顶堆：每个节点的值都大于等于子树中每个节点值的堆</p><p>小顶堆：每个节点的值都小于等于子树中每个节点值的堆</p></blockquote><p>堆中插入元素、删除元素的时间复杂度：O(logn)</p><p>堆排序的实现：</p><ol><li>建堆（时间复杂度O(n)）<ul><li>添加元素，从下往上堆化</li><li>用已有数组，从上往下建化</li></ul></li><li>排序<ul><li>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。</li><li>数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。</li><li>当堆顶元素移除之后，我们把原下标为 n 的元素放到堆顶，然后再通过堆化的方法，将剩下的 n-1 个元素重新构建成堆。</li><li>堆化完成之后，我们再取堆顶的元素，放到下标是 n-1 的位置，一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了。（类似删除堆顶元素）</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/PursueMilk/img/main/img/202302191009187.png" alt="image-20230219100931963"></p><blockquote><p>使用数组存储表示完全二叉树时，从数组下标为 1 开始存储数据，数组下标为 i 的节点，左子节点为 2i , 右子节点为 2i + 1 。<br>从数组下标为 0 开始存储数据，如果节点的下标是 i，那左子节点的下标就是 2 ∗ i + 1，右子节点的下标就是 2 ∗ i + 2，父节点的下标就是 (i-1)&#x2F;2。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 堆排</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">headSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//建堆</span><br>    builderHead(arr);<br>    <span class="hljs-comment">//排序</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 将堆顶元素与最后一个元素交换位置</span><br>        swap(arr, <span class="hljs-number">0</span>, length);<br>        <span class="hljs-comment">// 剩下元素重新堆化，将堆顶元素变成最大元素</span><br>        heapify(arr, --length, <span class="hljs-number">0</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 建堆</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">builderHead</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// (arr.length - 1) / 2 为最后一个叶子节点的父节点</span><br>    <span class="hljs-comment">// 也就是最后一个非叶子节点，依次堆化直到根节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (arr.length - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        heapify(arr, arr.length - <span class="hljs-number">1</span>, i);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 堆化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxPos</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//与左子节点比较，获取最大值位置</span><br>        <span class="hljs-keyword">if</span> (left &lt;= n &amp;&amp; arr[maxPos] &lt; arr[left]) &#123;<br>            maxPos = left;<br>        &#125;<br>        <span class="hljs-comment">//与右子节点比较，获取最大值位置</span><br>        <span class="hljs-keyword">if</span> (right &lt;= n &amp;&amp; arr[maxPos] &lt; arr[right]) &#123;<br>            maxPos = right;<br>        &#125;<br>        <span class="hljs-comment">// 如果最大值为当前节点，则结束</span><br>        <span class="hljs-keyword">if</span> (maxPos == i) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        swap(arr, maxPos, i);<br>        i = maxPos;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>为什么快排比堆排序性能要好？</p><ol><li>堆排序数据访问的方式没有快排友好：堆排序不是局部顺序访问，对CPU缓存不太友好</li><li>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序  <ul><li>快排基于比较和交换，其交换次数不会多于逆序度</li><li>堆排开始是建堆，其会打乱数据的原有顺序，导致数据的有序度降低</li></ul></li></ol></blockquote><h1 id="七、桶排序"><a href="#七、桶排序" class="headerlink" title="七、桶排序"></a>七、桶排序</h1><p>桶排序的核心思想：将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的。</p><p><img src="https://raw.githubusercontent.com/PursueMilk/img/main/img/202302191457418.png" alt="image-20230219145709309"></p><p>桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中  </p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><p><strong>稳定</strong>的排序算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 桶排序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bucketSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> bucketSize)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.length &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//获取数组的最小值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">//获取数组的最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : arr) &#123;<br>        max = Math.max(max, i);<br>        min = Math.min(min, i);<br>    &#125;<br>    <span class="hljs-comment">//桶的个数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">bucketCount</span> <span class="hljs-operator">=</span> (max - min) / bucketSize + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//创建 bucketCount 个桶</span><br>    List&lt;Integer&gt;[] buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[bucketCount];<br>    <span class="hljs-comment">// 将值分配到每个桶中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bucketIndex</span> <span class="hljs-operator">=</span> (arr[i] - min) / bucketSize;<br>        <span class="hljs-keyword">if</span> (buckets[bucketIndex] == <span class="hljs-literal">null</span>) &#123;<br>            buckets[bucketIndex] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>        buckets[bucketIndex].add(arr[i]);<br>    &#125;<br>    <span class="hljs-comment">// 对每个桶进行排序后再将值拷贝到原数组中</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;<br>        <span class="hljs-keyword">if</span> (buckets[i] == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        Collections.sort(buckets[i]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; buckets[i].size(); j++) &#123;<br>            arr[k++] = buckets[i].get(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了  </p></blockquote><h1 id="八、计数排序"><a href="#八、计数排序" class="headerlink" title="八、计数排序"></a>八、计数排序</h1><p>计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p><p><strong>缺点</strong>：</p><ol><li><p>只能用在<strong>数据范围不大</strong>的场景中，如果数据范围 k(最大值) 比要排序的数据 n 大很多，就不适合用计数排序了</p></li><li><p>只能给<strong>非负整数</strong>排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数</p></li></ol><p>时间复杂度：O(n)</p><p><strong>稳定</strong>的排序算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计数排序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countingSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//获取数据的范围</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        max = Math.max(arr[i], max);<br>    &#125;<br>    <span class="hljs-comment">//申请一个计数数组，下标范围 [0,max+1]</span><br>    <span class="hljs-type">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//计算每个元素的个数放入数组C中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        c[arr[i]]++;<br>    &#125;<br>    <span class="hljs-comment">//依次累加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; c.length; i++) &#123;<br>        c[i] += c[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">//临时数组r，存储排序之后的结果</span><br>    <span class="hljs-type">int</span>[] r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-comment">//原数组中元素的在临时数组中的位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">//找到该元素的下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> c[arr[i]] - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//赋值</span><br>        r[index] = arr[i];<br>        c[arr[i]]--;<br>    &#125;<br>    <span class="hljs-comment">//将排序后的结构拷贝给原数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        arr[i] = r[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>为什么计数后还要开临时数组，为什么不直接通过计数直接赋值？</p><p>如果是单纯的数据排序可以，但是如果有对应的信息则不行，因为要清楚对应的分数所对应的信息。(如：成绩信息，小红 95，小李 95，那么第一个 95 对应的是那位同学需要通过后续的操作进行确定)</p></blockquote><h1 id="九、基数排序"><a href="#九、基数排序" class="headerlink" title="九、基数排序"></a>九、基数排序</h1><p>基数排序对要排序的数据是有要求的，需要可以分割出独立的 <strong>“位”</strong> 来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。  </p><p>时间复杂度：O(n)</p><p><strong>稳定</strong>的排序算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基数排序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        max = Math.max(arr[i], max);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; max / exp &gt; <span class="hljs-number">0</span>; exp *= <span class="hljs-number">10</span>) &#123;<br>        radixCountingSort(arr, exp);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计数排序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixCountingSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> exp)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.length &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 计算每个元素的个数</span><br>    <span class="hljs-type">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        c[(arr[i] / exp) % <span class="hljs-number">10</span>]++;<br>    &#125;<br>    <span class="hljs-comment">//累加元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        c[i] += c[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">//计算排序后的位置</span><br>    <span class="hljs-type">int</span>[] r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> c[(arr[i] / exp) % <span class="hljs-number">10</span>] - <span class="hljs-number">1</span>;<br>        r[index] = arr[i];<br>        c[(arr[i] / exp) % <span class="hljs-number">10</span>]--;<br>    &#125;<br>    <span class="hljs-comment">// 拷贝数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        arr[i] = r[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2023/02/09/%E9%98%9F%E5%88%97/"/>
    <url>/2023/02/09/%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="一、知识"><a href="#一、知识" class="headerlink" title="一、知识"></a>一、知识</h1><p>队列这个概念非常好理解。你可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。先进者先出，这就是典型的“队列”。  </p><p>队列跟栈一样，也是一种操作受限的线性表数据结构 。队列最基本的操作也是两个：入队：放一个数据到队列尾部；出队：从队列头部取一个元素。用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。  </p><p>项目中用到的特殊队列：阻塞队列、并发队列等。（阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全）</p><p><img src="https://raw.githubusercontent.com/PursueMilk/img/main/img/image-20230206200434403.png" alt="image-20230206200434403"></p><h1 id="二、应用"><a href="#二、应用" class="headerlink" title="二、应用"></a>二、应用</h1><h2 id="1-设计循环双端队列"><a href="#1-设计循环双端队列" class="headerlink" title="1. 设计循环双端队列 "></a>1. <a href="https://leetcode.cn/problems/design-circular-deque/">设计循环双端队列 </a></h2><p>可以通过数组、链表实现循环双端队列，下面方法通过数组实现，需要注意的点为：头尾指针变动需要进行特殊处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCircularDeque</span> &#123;<br><br><span class="hljs-comment">//数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] arr;<br>    <span class="hljs-comment">//头指针</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> start;<br>    <span class="hljs-comment">//尾指针</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> end;<br>    <span class="hljs-comment">//队列长度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCircularDeque</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-comment">//循环队列有一个空间不能使用，需要开k+1个空间</span><br>        arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k + <span class="hljs-number">1</span>];<br>        size = k + <span class="hljs-number">1</span>;<br>        start = <span class="hljs-number">0</span>;<br>        end = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insertFront</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//防止头节点减1变为负数</span><br>        start = (start - <span class="hljs-number">1</span> + size) % size;<br>        arr[start] = value;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insertLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        arr[end] = value;<br>        <span class="hljs-comment">//对size取模</span><br>        end = (end + <span class="hljs-number">1</span>) % size;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteFront</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//取模</span><br>        start = (start + <span class="hljs-number">1</span>) % size;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//防止end减1变成负数</span><br>        end = (end - <span class="hljs-number">1</span> + size) % size;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFront</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[start];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRear</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[(end - <span class="hljs-number">1</span> + size) % size];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> end == start;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (end + <span class="hljs-number">1</span>) % size == start;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-滑动窗口最大值"><a href="#2-滑动窗口最大值" class="headerlink" title="2. 滑动窗口最大值"></a>2. <a href="https://leetcode.cn/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/">滑动窗口最大值</a></h2><p>双端队列存储长为 k 的滑动窗口的下标，为什么存下标：判断该数是否在窗口中。将元素存入双端队列时，应将该元素与队列中最后的元素进行判断，小于则弹出最后的元素，直至队列中元素大于等于该元素或者队列为空，这样队首元素即为当前窗口的最大元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-comment">//双端队列</span><br>    Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>();<br>    <span class="hljs-comment">//将 k 个元素加入双端队列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;<br>            deque.pollLast();<br>        &#125;<br>        deque.offerLast(i);<br>    &#125;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>    arr[<span class="hljs-number">0</span>] = nums[deque.peekFirst()];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">//判断队列元素是否在窗口中</span><br>        <span class="hljs-keyword">if</span> (deque.peek() + k - <span class="hljs-number">1</span> &lt; i) &#123;<br>            deque.poll();<br>        &#125;<br>        <span class="hljs-comment">//弹出队列中小于该元素的数</span><br>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;<br>            deque.pollLast();<br>        &#125;<br>        <span class="hljs-comment">//将该数添加到队列中</span><br>        deque.offerLast(i);<br>        <span class="hljs-comment">//当前窗口的最大值</span><br>        arr[i - k + <span class="hljs-number">1</span>] = nums[deque.peekFirst()];<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-队列的最大值"><a href="#3-队列的最大值" class="headerlink" title="3. 队列的最大值"></a>3. <a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/">队列的最大值</a></h2><p>创建两个队列，一个为双端队列用于存储最大值（方法和第二题一样），需要出队时判断普通队列和双端队列的队首的值是否一样，一样则出队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> Deque&lt;Integer&gt; deque;<br>    <span class="hljs-comment">//双端队列</span><br>    <span class="hljs-keyword">private</span> Deque&lt;Integer&gt; maxDeque;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MaxQueue</span><span class="hljs-params">()</span> &#123;<br>        deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>();<br>        maxDeque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max_value</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (maxDeque.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxDeque.peek();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">//与第二题一样</span><br>        <span class="hljs-keyword">while</span> (!maxDeque.isEmpty() &amp;&amp; maxDeque.peekLast() &lt; value) &#123;<br>            maxDeque.pollLast();<br>        &#125;<br>        deque.offerLast(value);<br>        maxDeque.offerLast(value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop_front</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (deque.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//两个对首值xiang&#x27;d</span><br>        <span class="hljs-keyword">if</span> (deque.peek().equals(maxDeque.peek())) &#123;<br>            maxDeque.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> deque.poll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2023/01/31/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/01/31/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>代理模式即在不改变原始类或叫被代理类代码的情况下，通过引入代理类来给原始类附加功能。  </p><p>代理模式分为<strong>静态代理</strong>、<strong>动态代理</strong>。静态代理需要针对每个类都创建一个代理类（每个代理类中的代码都有点像模板式的<strong>重复</strong>代码）增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。  动态代理即不事先为每个原始类编写代理类，而是在<strong>运行</strong>的时候，<strong>动态地</strong>创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。  (动态代理底层依赖的就是 Java 的反射语法)</p><blockquote><p>实际上，Spring AOP 底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring 为这些类创建动态代理对象，并在 JVM 中替代原始类对象。  原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。  </p></blockquote><h1 id="二、-实现"><a href="#二、-实现" class="headerlink" title="二、 实现"></a>二、 实现</h1><h2 id="1-Java动态代理"><a href="#1-Java动态代理" class="headerlink" title="1. Java动态代理"></a>1. Java动态代理</h2><p>定义接口以及实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MessageService</span> &#123;<br>    String <span class="hljs-title function_">sendMessage</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MessageService</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sendMessage</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;发送消息&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送消息成功&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现InvocationHandler接口</p><blockquote><pre><code class="hljs">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;invoke方法中proxy为动态生成的代理类、method为代理类调用的方法对象，args为当前方法调用的参数。</code></pre></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServiceProxy</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">//添加的业务</span><br>        System.out.println(<span class="hljs-string">&quot;代理类执行的操作&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>通过Proxy.newInstance()方法获得代理对象</p><blockquote><p>public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces, InvocationHandler h)方法中loader为类加载器，用于加载代理对象，interfaces为被代理对象实现的接口，h为实现InvocationHanlder接口的对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceProxyFactory</span> &#123;<br>    <span class="hljs-comment">//获取代理对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">createProxy</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),<br>                target.getClass().getInterfaces(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceProxy</span>(target));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序，程序执行结果如下图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">MessageService service= (MessageService) ServiceProxyFactory.createProxy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageServiceImpl</span>());<br>System.out.println(service.sendMessage());<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202301292149722.png" alt="image-20230129214902576"></p><h2 id="2-CGLIB-动态代理机制"><a href="#2-CGLIB-动态代理机制" class="headerlink" title="2. CGLIB 动态代理机制"></a>2. CGLIB 动态代理机制</h2><p>引入cglib的jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>被代理类的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sendMessage</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;发送消息&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送消息成功&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现MethodInterceptor接口中的intercept方法，创建代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageIntercept</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <br>    <span class="hljs-comment">//获取代理类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> &#123;<br>        <span class="hljs-comment">//创建增强类</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        <span class="hljs-comment">//设置类加载器</span><br>        enhancer.setClassLoader(clazz.getClassLoader());<br>        <span class="hljs-comment">//设置被代理类</span><br>        enhancer.setSuperclass(clazz);<br>        <span class="hljs-comment">//设置方法拦截器</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageIntercept</span>());<br>        <span class="hljs-comment">//创建代理类</span><br>        <span class="hljs-keyword">return</span> (T) enhancer.create();<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 增强被代理类的方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o 被代理的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method 被拦截的方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> objects 方法的参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> methodProxy 用于调用原始方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;代理类执行的操作&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(o, objects);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MessageService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> getProxy(MessageService.class);<br>        System.out.println(service.sendMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Java动态代理和CGLIB的对比</strong></p><ol><li>Java动态代理只能代理实现了接口的类或直接代理接口，CGLIB可以代理未实现任何接口的类。</li><li>Java动态代理通过反射机制实现一个代理接口的匿名类在调用具体方法前用InvokeHandler处理，cglib利用ASM开源包，通过修改被代理对象的class文件生成子类来处理。</li></ol><blockquote><p>CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</p><p>ASM: 一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。</p><p>Java中,动态代理的实现基于字节码生成技术,可以在jvm运行时动态生成和加载字节码并加载到JVM中，而静态代理在编译期则将接口、实现类、代理类编译为class文件</p></blockquote><h1 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h1><ol><li><p><strong>业务系统的非功能性需求开发</strong>：代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。</p></li><li><p><strong>代理模式在 RPC、缓存中的应用</strong>，我自己写的<a href="https://github.com/PursueMilk/Parody-RPC">RPC项目</a>中就用到了代理模式，目的是为了让RPC的使用者不用关注客户端交互的细节，只需要开发业务逻辑，就像使用本地方法一样。</p></li></ol><p><strong>参考资料</strong></p><ol><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453152414&idx=1&sn=136b1aa16d9822909260b8e80ab14ca0&scene=21#wechat_redirect">代理模式</a></p></li><li><p><a href="https://javaguide.cn/java/basis/proxy.html">Java 代理模式详解</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>结构型</tag>
      
      <tag>代理模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2023/01/24/%E6%95%B0%E7%BB%84/"/>
    <url>/2023/01/24/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一、知识"><a href="#一、知识" class="headerlink" title="一、知识"></a>一、知识</h1><p>数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。  最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。  </p><h1 id="二、应用"><a href="#二、应用" class="headerlink" title="二、应用"></a>二、应用</h1><h2 id="1-三数之和"><a href="#1-三数之和" class="headerlink" title="1.  三数之和"></a>1. <a href="https://leetcode.cn/problems/3sum/"> 三数之和</a></h2><p>排序+双指针</p><ul><li>排序，排序让数组有序可以通过双指针来查找符合要求的元素，不排序则只能选取一个元素，再从剩下的元素中再选取一个，再去找最后一个元素，这样时间复杂度太高会超时</li><li>双指针，排好序后选定一个元素，使用双指针只要遍历一次数组即可查找出符合要求的其余两个元素，n个元素遍历n次，时间复杂度为O(n^2^)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">//排序</span><br>    Arrays.sort(nums);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>    List&lt;List&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//选定元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-comment">//当该元素大于0则结束</span><br>        <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//防止重复选定相同数值的元素</span><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//双指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, k = length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[j] + nums[k];<br>            <span class="hljs-keyword">if</span> (sum &gt; -nums[i]) &#123;<br>                k--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; -nums[i]) &#123;<br>                j++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//所有元素符合要求，则加入集合</span><br>                list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(nums[i], nums[j], nums[k])));<br>                j++;<br>                k--;<br>                <span class="hljs-comment">//防止重复选定相同数值的元素</span><br>                <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    j++;<br>                &#125;<br>                <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k + <span class="hljs-number">1</span>]) &#123;<br>                    k--;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-多数元素"><a href="#2-多数元素" class="headerlink" title="2. 多数元素"></a>2.<a href="https://leetcode.cn/problems/majority-element/"> 多数元素</a></h2><ol><li>哈希表<ul><li>将元素以及元素的个数存入哈希表中再次遍历哈希表找出元素个数大于n&#x2F;2的元素</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>        map.put(i, map.getOrDefault(i, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> nums.length / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;<br>        <span class="hljs-keyword">if</span> (entry.getValue() &gt; pass) &#123;<br>            num = entry.getKey();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>摩尔投票法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>        <span class="hljs-keyword">if</span> (i == cur) &#123;<br>            num++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (--num == <span class="hljs-number">0</span>) &#123;<br>            cur = i;<br>            num = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-缺失的第一个正数"><a href="#3-缺失的第一个正数" class="headerlink" title="3.  缺失的第一个正数"></a>3. <a href="https://leetcode.cn/problems/first-missing-positive/"> 缺失的第一个正数</a></h2><p>置换</p><ul><li>题意要求找出为出现的最小整数，出现在1 ~ n范围的整数符合要求，我们可以利用原数组将在1 ~ n范围中的数 a 移动到数组下标为   a-1的位置（移动前需要判断原位置是否存在符合要求的值，防止死循环）,当所有元素换完后遍历数组，当前元素不为下标+1时，则该位置的数为缺失的第一个正数，遍历完成未发现则为 n+1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">//置换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[nums[i] - <span class="hljs-number">1</span>];<br>                nums[nums[i] - <span class="hljs-number">1</span>] = nums[i];<br>                nums[i] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//查看当前的数是否符合要求</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> ((i + <span class="hljs-number">1</span>) != nums[i]) &#123;<br>                <span class="hljs-comment">//不符合直接返回</span><br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//未找到则为n+1</span><br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2023/01/23/%E6%A0%88/"/>
    <url>/2023/01/23/%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="一、知识"><a href="#一、知识" class="headerlink" title="一、知识"></a>一、知识</h1><p>栈是一种”操作受限”的线性表，只允许在一端插入和删除数据。后进者先出，先进者后出，这就是典型的“栈”结构。</p><p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。</p><p>栈的空间复杂度为O(1)（这里需要n个空间保存数据并不是说空间复杂度即为O(n)，而是该n个空间是必须的无法省略），不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是 O(1) 。</p><p><strong>Java中栈的实现</strong>：Vector类具有动态扩容和随机访问的特性，因此，继承了Vector类的Stack也同样具有这些特性，这恰好违背了Stack数据结构的设计原理，正因为如此，Java中的Stack一直被认为是糟糕的实现，官方也将Stack标志为“弃用”。<strong>官方推荐使用Deque（双端队列）接口来实现Stack</strong>。</p><h1 id="二、应用"><a href="#二、应用" class="headerlink" title="二、应用"></a>二、应用</h1><h2 id="1-有效的括号"><a href="#1-有效的括号" class="headerlink" title="1.有效的括号"></a>1.<a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a></h2><p>使用map存储配对的字符，当字符为map中的key时字符入栈，当字符不为map的key时字符出栈进行对比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-comment">//如果字符串长度不为偶数直接结束</span><br>    <span class="hljs-keyword">if</span> (length % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//map存储配对字符</span><br>    Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;() &#123;<br>        &#123;<br>            put(<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>);<br>            put(<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>);<br>            put(<span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">//deque实现栈</span><br>    Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">elt</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <span class="hljs-comment">//判断map中是否存在key</span><br>        <span class="hljs-keyword">if</span> (map.containsKey(elt)) &#123;<br>            stack.push(elt);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断是否栈空，不为空再比较字符是否配对</span><br>        <span class="hljs-keyword">if</span> (stack.isEmpty() || map.get(stack.pop()) != elt) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//判断是否栈空，字符是否配对完</span><br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-最小栈"><a href="#2-最小栈" class="headerlink" title="2.最小栈"></a>2.<a href="https://leetcode.cn/problems/min-stack/">最小栈</a></h2><p>使用两个栈，一个栈存储数据，一个栈存储最小值这样在常数时间内能找到最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    <br>    Deque&lt;Integer&gt; stack;<br>    <span class="hljs-comment">//存储最小值</span><br>    Deque&lt;Integer&gt; minStack;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        <span class="hljs-comment">//添加入最大值与添加的数据进行大小比较</span><br>        minStack.push(Integer.MAX_VALUE);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        stack.push(val);<br>        <span class="hljs-comment">//将值与最小值中的栈顶值比较，添加较小的值</span><br>        minStack.push(Math.min(minStack.peek(), val));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        stack.pop();<br>        minStack.pop();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peek();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> minStack.peek();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-用栈实现队列"><a href="#3-用栈实现队列" class="headerlink" title="3.用栈实现队列"></a>3.<a href="https://leetcode.cn/problems/implement-queue-using-stacks/">用栈实现队列</a></h2><p>使用两个栈来实现队列，一个栈（tail）实现数据的入队，另外一个栈（head）实现数据的出队，当出队数据为空时判断tail栈是否存在数据，将数据添加至head栈实现数据的正序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    Deque&lt;Integer&gt; head;<br>    Deque&lt;Integer&gt; tail;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        tail.push(x);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        exchange();<br>        <span class="hljs-keyword">return</span> head.pop();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        exchange();<br>        <span class="hljs-keyword">return</span> head.peek();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (head.isEmpty() &amp;&amp; tail.isEmpty());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//判断head栈是否存为空</span><br>        <span class="hljs-keyword">if</span> (!head.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断tail栈是否为空</span><br>        <span class="hljs-keyword">if</span> (!tail.isEmpty()) &#123;<br>            <span class="hljs-comment">//进行数据的转移</span><br>            <span class="hljs-keyword">while</span> (!tail.isEmpty()) &#123;<br>                head.push(tail.pop());<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-基本计算器"><a href="#4-基本计算器" class="headerlink" title="4.基本计算器"></a>4.<a href="https://leetcode.cn/problems/basic-calculator/">基本计算器</a></h2><p>将括号前的符号存入栈中，括号中的计算都要变换符号，当括号结束再出栈变为括号之前的符号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-comment">//最开始的符号</span><br>        stack.push(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">elt</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">switch</span> (elt) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27; &#x27;</span>:<br>                    i++;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                    ret = stack.peek();<br>                    i++;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                    ret = -stack.peek();<br>                    i++;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>                    stack.push(ret);<br>                    i++;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<br>                    stack.pop();<br>                    i++;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                    <span class="hljs-comment">//循环遍历找出完整的数字</span><br>                    <span class="hljs-keyword">while</span> (i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i))) &#123;<br>                        num = num * <span class="hljs-number">10</span> + s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                        i++;<br>                    &#125;<br>                    sum += ret * num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-逆波兰表达式求值"><a href="#5-逆波兰表达式求值" class="headerlink" title="5.逆波兰表达式求值"></a>5.<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">逆波兰表达式求值</a></h2><p>逆波兰表达式主要有以下两个优点：</p><ul><li><p>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果</p></li><li><p>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>    Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> tokens.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> tokens[i];<br>        <span class="hljs-comment">//判断是否是数字</span><br>        <span class="hljs-keyword">if</span> (!isNumber(temp)) &#123;<br>            stack.push(Integer.valueOf(temp));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//不为数字则进行运算，运算结果入栈</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> stack.pop();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> stack.pop();<br>            <span class="hljs-keyword">switch</span> (temp) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                    stack.push(num1 + num2);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                    stack.push(num2 - num1);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                    stack.push(num2 / num1);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                    stack.push(num1 * num2);<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//将栈中的最终结果fan</span><br>    <span class="hljs-keyword">return</span> stack.pop();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumber</span><span class="hljs-params">(String temp)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;+&quot;</span>.equals(temp) || <span class="hljs-string">&quot;*&quot;</span>.equals(temp) || <span class="hljs-string">&quot;-&quot;</span>.equals(temp) || <span class="hljs-string">&quot;/&quot;</span>.equals(temp);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-下一个更大元素-I"><a href="#6-下一个更大元素-I" class="headerlink" title="6.下一个更大元素 I"></a>6.<a href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素 I</a></h2><p>单调栈+哈希表：首先从后遍历数组nums2，单调栈用于存储当前位置后比当前元素大的元素，每次进行比较，当前元素小于栈内元素则当前元素后的最大元素为栈顶元素，否则将元素出栈找到最大的元素，不存在则为-1，使用map可以在遍历nums1数组时找到nums2对应位置的下个最大元素（也可以存储下标代替值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] nextGreaterElement(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        <span class="hljs-comment">//单调栈</span><br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums2.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums2[i];<br>            <span class="hljs-comment">//判断栈是否为空，不为空比较大小</span><br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt;= temp) &#123;<br>                stack.pop();<br>            &#125;<br>            <span class="hljs-comment">//不为空栈顶元素为最大元素，否则为-1</span><br>            map.put(temp, stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek());<br>            stack.push(temp);<br>        &#125;<br>        <span class="hljs-comment">//遍历nums1数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            arr[i] = map.get(nums1[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-最长有效括号"><a href="#7-最长有效括号" class="headerlink" title="7.最长有效括号"></a>7.<a href="https://leetcode.cn/problems/longest-valid-parentheses/">最长有效括号</a></h2><p>栈：将 ( 的下标压入栈中，当遇到 ) 时将出栈，通过栈是否为空判断是否为该 ) 是否存在对应的 ( </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">//栈</span><br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//防止第一个为 )，出栈出现异常 </span><br>        stack.push(-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">elt</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (elt == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                stack.push(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.pop();<br>                <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                    stack.push(i);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    max = Math.max(max, i - stack.peek());<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2023/01/23/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/01/23/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java版本划分"><a href="#Java版本划分" class="headerlink" title="Java版本划分"></a>Java版本划分</h1><ol><li><strong>Java SE</strong>-标准版，主要用于普通PC、工作站的Java控制台或桌面程序的基础开发</li><li><strong>Java ME</strong>-微型版，用于移动设备、嵌入式设备上的Java应用程序开发。</li><li><strong>Java EE</strong>-企业版，用于开发、部署和管理企业级、可扩展的大型软件或Web应用。</li></ol><blockquote><p>J2SE、J2ME、J2EE与Java SE、Java ME、Java EE的关系？</p><p>答：Java5.0版本后，J2SE、J2EE、J2ME分别更名为Java SE、Java EE、Java ME，由于习惯的原因，我们依然称之为J2SE、J2EE、J2ME。</p></blockquote><h1 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h1><ol><li>简单性：Java衍生于C&#x2F;C++，但它略去了C&#x2F;C++中学习起来比较难的多继承、指针等概念，并通过自动垃圾回收机制大大简化了程序员的内存管理工作，所以Java语言学习起来更简单，使用起来也更方便。</li><li>面向对象：Java是一种面向对象的编程语言。</li><li>分布式：Java是面向网络的语言，通过它提供的类库可以处理TCP&#x2F;IP协议，用户可以通过URL地址在网络上很方便地访问其他对象。</li><li>健壮性：Java非常强调早期的问题检测、后期动态的检测，以及消除容易出错的情况，其采用的指针模型可以消除重写内存和损坏数据的可能性。</li><li>安全性：Java不支持指针，一切对内存的访问都必须通过对象实例来完成，有效的防止黑客使用欺骗手段访问对象的私有成员，同时也避免由于指针操作导致程序或系统崩溃。</li><li>可移植性：Java并不依赖平台，用Java编写的程序可以移植到不同的操作系统上。</li><li>解释型：Java解释器可以在任何移植了解释器的机器上直接执行Java字节码。</li><li>高性能：字节码可以（在运行时）动态地转换成对应运行这个应用地特定CPU地机器码。（即时编译器可以监控哪些代码频繁执行，并优化这些代码提高速度）</li><li>多线程：Java支持并发程序设计，它可以同时执行多个程序，能处理不同任务。</li><li>动态性：库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。</li></ol><h1 id="JDK、JRE、JVM的区别"><a href="#JDK、JRE、JVM的区别" class="headerlink" title="JDK、JRE、JVM的区别"></a>JDK、JRE、JVM的区别</h1><p> JDK（ Java Development Kit ），Java开发工具包，提供了编译、运行Java程序所需要的各种工具 ，除了包含JRE以外还包含了开发Java程序所必须的命令工具。</p><p> JRE（ Java Runtime Environment），Java运行环境，主要包含两个部分：JVM和Java系统类库。所有的Java 程序都要在JRE下才能运行。普通用户需要运行已开发好的Java程序，只需要安装JRE即可。</p><p>JVM（ Java Virtual Mechinal ），Java虚拟机，负责加载、执行字节码文件(.class)，每种类型的操作系统都有一种对应的JVM，JVM屏蔽了底层操作系统的差异，使Java程序能够做到”一次编写，多处运行“。</p><blockquote><p>JDK&#x3D;JRE+编译、运行等命令工具</p><p>JRE&#x3D;JVM+Java系统类库</p></blockquote><h1 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h1><p>switch-case语句中，case的标签可以是：</p><ul><li>类型为char、byte、short或int的常量表达式（能自动转为int的类型，否则必须进行强制类型转换）</li><li>枚举常量</li><li>从Java7开始，case标签还可以是字符串字面量</li></ul><h1 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h1><p>重载：同一个方法对于输入的数据不同，做出不同的响应</p><ul><li>方法名相同</li><li>形参不同：数据类型不同或参数顺序不同</li><li>访问修饰符、返回类型不做要求</li></ul><p>重写：当子类继承父类的方法需，当输入的数据相同需要做出不同于父类的响应时，覆盖父类的方法</p><ul><li>方法名相同、参数相同</li><li>抛出的异常小于等于父类抛出的异常、返回的类型与父类返回类型相同或为其子类（void、基本类型不能被修改）</li><li>访问修饰符大于等于父类</li></ul><blockquote><p>静态方法、构造方法不能被重写，重载为编译期、重写为运行期</p></blockquote><h1 id="String中compareTo-与equals-的区别"><a href="#String中compareTo-与equals-的区别" class="headerlink" title="String中compareTo()与equals()的区别"></a>String中compareTo()与equals()的区别</h1><p>int compareTo(String other)：按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0</p><p>boolean equals(Object other)：如果字符串与other相等，返回true</p><h1 id="Comparator和Comparable的区别"><a href="#Comparator和Comparable的区别" class="headerlink" title="Comparator和Comparable的区别"></a>Comparator和Comparable的区别</h1><p>comparable接口出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</p><p>comparator接口出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</p><blockquote><p>Comparator和Comparable一般都用于实现排序，如：Collections.sort(List<T> list, Comparator&lt;? super T&gt; c) 方法可以通过传入Comparator实现类来自定义排序。</p></blockquote><h1 id="基本类型和包装类的区别"><a href="#基本类型和包装类的区别" class="headerlink" title="基本类型和包装类的区别"></a>基本类型和包装类的区别</h1><ul><li>成员变量为基本类型会有默认值不为null，包装类型默认默认值为null</li><li>包装类型可用于泛型，基本类型不能用于泛型</li><li>基本数据类型占用空间更小</li><li>基本类型的局部变量存在于虚拟机栈中，基本类型的成员变量存在于堆中，包装类型属于对象类型，基本存在于堆中</li></ul><blockquote><p>在Java 5中，引入了自动装箱（ 调用包装类的valueOf() ）和自动拆箱（ 调用xxxValue() ）功能， Java可以根据上下文，自动进行转换，极大地简化了相关编程。</p><p>在Java 5中新增了静态工厂方法valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进：Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。 </p></blockquote><h1 id="面向对象与面向过程的区别"><a href="#面向对象与面向过程的区别" class="headerlink" title="面向对象与面向过程的区别"></a>面向对象与面向过程的区别</h1><p>主要为解决问题的方式不同</p><ul><li>面向过程会将解决问题的过程拆成一个个方法，通过执行一个个方法解决问题</li><li>面向对象会抽象出对象，通过对象执行方法的方式解决问题</li></ul><h1 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h1><ol><li><p>封装：把一个对象的属性隐藏在对象内部，不允许外部对象直接访问对象的属性，但是可以提供一些可以被外界访问的方法来操作属性。</p></li><li><p>继承：使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</p></li><li><p>多态：一个对象具有多种状态，具体表现为父类指向子类实例</p></li></ol><blockquote><p>通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。子类拥有父类所有属性和方法（包括私有），但是父类中的私有属性和方法不能访问。</p></blockquote><h1 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h1><p>相同点：</p><ul><li>不能被实例化</li><li>可以包含抽象方法</li><li>可以有默认的实现方法</li></ul><p>不同点：</p><ul><li>接口主要用于对类的行为进行约束，让实现类具有特定的行为（方法）。抽象类主要用于代码的复用，定义类之间的关系</li><li>一个类可以实现多个接口，但只能继承一个类</li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法</li><li>接口中的成员变量为public static final 类型，不能被修改且必须有初始值。抽象类的成员变量可以为各种类型</li></ul><blockquote><p>接口中的抽象方法为public abstract、抽象类中抽象方法为 public 或 protected </p></blockquote><h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><p>浅拷贝：在堆中创建一个新的对象，当原对象内部的属性为引用类型时，浅拷贝直接复制其引用地址，拷贝对象和原对象的内部属性指向同一个内部对象。</p><p>深拷贝：深拷贝会复制整个对象包括内部引用类型属性所引用的对象。</p><h1 id="Object中常见的方法"><a href="#Object中常见的方法" class="headerlink" title="Object中常见的方法"></a>Object中常见的方法</h1><ol><li>equals比较两个对象内存地址是否相等</li><li>hashCode  返回对象的hash码（int整数）</li><li>toString 返回类名字的哈希码的16进制字符串</li><li>wait   暂停线程</li><li>notify  唤醒在一个在该对象中暂停的线程</li><li>notifyAll  唤醒在该对象中暂停的所有线程</li><li>getClass 获取该类的类对象</li><li>finalize  垃圾回收时执行的方法</li></ol><h1 id="为什么重写equals-方法必须要重写hashCode-方法？"><a href="#为什么重写equals-方法必须要重写hashCode-方法？" class="headerlink" title="为什么重写equals()方法必须要重写hashCode()方法？"></a>为什么重写equals()方法必须要重写hashCode()方法？</h1><p>两个对象相等则其hash值相等，通过equals方法判断两个对象相等则其hashCode值相等。当重写equals不重写hashCode时，可能会出现equals判断两个对象相等，但其hash值不相等。</p><h1 id="String为什么是不可变的？"><a href="#String为什么是不可变的？" class="headerlink" title="String为什么是不可变的？"></a>String为什么是不可变的？</h1><ol><li>保存字符串的数组被final修饰且为私有的，String类并没有提供修改这个字符串数组中值的方法</li><li>String被final修饰不能被继承避免了子类破坏String的不可变。</li></ol><h1 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h1><p>String是Java语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的Immutable类，被声明成为final class，所有属性也都是final的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的String对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。</p><p>StringBufer是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用append或者add方法，把字符串添加到已有序列的末尾或者指定位置。 StringBufer本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是StringBuilder。</p><p>StringBuilder是Java 1.5中新增的，在能力上和StringBufer没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。 </p><blockquote><p>为了实现修改字符序列的目的， StringBufer和StringBuilder底层都是利用可修改的（char， JDK 9以后是byte）数组，二者都继承了AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了synchronized。</p><p>构建时初始字符串长度为16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是16)</p></blockquote><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型，使用泛型后从容器中取出对象编译器自动转换对象类型。</p><h1 id="对Java平台的理解"><a href="#对Java平台的理解" class="headerlink" title="对Java平台的理解"></a>对Java平台的理解</h1><ol><li>Java语言本身、JDK中提供的核心类库和相关工具</li></ol><ul><li>面向对象（封装、继承、多态）</li><li>跨平台（一次书写到处运行，跨平台能力）</li><li>语言（泛型、Lambda）</li><li>类库（集合、网络、并发、IO&#x2F;NIO）</li><li>工具（基本的编译工具、虚拟机性能诊断工具）</li></ul><ol start="2"><li>Java虚拟机</li></ol><ul><li>垃圾收集(GC)，Java通过垃圾收集器回收分配内存，程序员不需要自己操心内存的分配和回收</li><li>对于虚拟机而言，只要是符合规范的字节码，它们都能被加载执行，当然，能正常运行的程序光满足这点是不行的，程序本身需要保证在运行时不出现异常。所以， Scala、 Kotlin、 Jython等语言也可以跑在虚拟机上。</li></ul><h1 id="Java是解释执行的吗？"><a href="#Java是解释执行的吗？" class="headerlink" title="Java是解释执行的吗？"></a>Java是解释执行的吗？</h1><p>Java是解释执行这句话不太准确，首先Java源代码通过Javac编译为字节码，通过 Java虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。但是常见的JVM都提供了JIT编译器(动态编译器)，JIT能过在运行时将热点代码编译成机器码，这种情况下这部分热点代码属于编译执行，而不是解释执行。Java 9提供的AOT编译器可以直接将所有代码编译成机器码执行。 </p><blockquote><p>Java采用的是解释和编译混合的模式。它首先通过javac将源码编译成字节码文件class.然后在运行的时候通过解释器或者JIT将字节码转换成最终的机器码。<br>只是用解释器的缺点：抛弃了JIT可能带来的性能优势。如果代码没有被JIT编译的话，再次运行时需要重复解析。<br>只用JIT的缺点：<br>需要将全部的代码编译成本地机器码。要花更多的时间， JVM启动会变慢非常多；<br>增加可执行代码的长度（字节码比JIT编译后的机器码小很多），这将导致页面调度，从而降低程序的速度。<br>有些JIT编译器的优化方式，比如分支预测，如果不进行profling，往往并不能进行有效优化。<br>因此， HotSpot采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。 JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。<br>JDK 9引入了一种新的编译模式AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。 JDK支持分层编译和AOT协作使用。<br>注： JIT为方法级，它会缓存编译过的字节码在CodeCache中，而不需要被重复解释  </p></blockquote><h1 id="为什么不全部使用-AOT-呢？"><a href="#为什么不全部使用-AOT-呢？" class="headerlink" title="为什么不全部使用 AOT 呢？"></a>为什么不全部使用 AOT 呢？</h1><p>这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p><h1 id="对于一次编译，到处运行的理解"><a href="#对于一次编译，到处运行的理解" class="headerlink" title="对于一次编译，到处运行的理解"></a>对于一次编译，到处运行的理解</h1><p>一次编译，到处运行说的是Java语言跨平台的特性，程序从源代码到运行经过三个阶段：编码-编译-运行，Java在编译阶段体现了跨平台的特点，编译的大概过程：首先将Java源代码通过Javac编译为.CLASS文件字节码，该字节码文件即为可到处运行的文件，然后字节码会被转变为机器码，这是由JVM来执行的，即Java的第二次编译。</p><p>到处运行的关键和前提就是JVM，因为在第二次编译中JVM起着关键作用。在可以运行Java虚拟机的地方都内含着一个JVM操作系统，从而使Java提供了各种不同平台上的虚拟机制、屏蔽不同操作系统之间的差异，因此实现了“到处运行”的效果 。 </p><blockquote><p>其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编译，到处运行这样的效果。</p></blockquote><h1 id="Exception和Error的区别"><a href="#Exception和Error的区别" class="headerlink" title="Exception和Error的区别"></a>Exception和Error的区别</h1><p>Exception和Error都是继承了Throwable类，在Java中只有Throwable类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。Exception和Error体现了Java平台设计者对不同异常情况的分类。 </p><ul><li><p>Error：系统错误类，是指在正常情况下，不大可能出现的情况，代表程序运行时Java系统内部错误，一般由硬件或操作系统引发。既然是非正常情况，所以不便于也不需要捕获，常见的比如OutOfMemoryError之类，都是Error的子类。</p></li><li><p>Exception：异常类，是程序正常运行中，可以预料的意外情况，应该被捕获并进行相应处理。它包含子类RuntimeException、IOException异常，RuntimeException类表示Java程序运行时产生的异常，如数组下标越界、对象类型强制转换错误、空指针等，IOException类及其子类表示各种I&#x2F;O错误。</p></li></ul><blockquote><p>异常又分为检查（checked）异常和非检查（unchecked）异常，检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。Error和RuntimeException类及其子类为非检查异常，IOException类及其子类为检查异常。</p><p>非检查异常就是所谓的运行时异常，类似 NullPointerException、 ArrayIndexOutOfBoundsException之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。  </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202301011811770.png" alt="image-20230101181148657"></p><h1 id="NoClassDefFoundError和ClassNotFoundException的区别"><a href="#NoClassDefFoundError和ClassNotFoundException的区别" class="headerlink" title="NoClassDefFoundError和ClassNotFoundException的区别"></a>NoClassDefFoundError和ClassNotFoundException的区别</h1><p>ClassNotFoundException的产生原因主要是：</p><ul><li><p>Java支持使用反射方式在运行时动态加载类，例如使用Class.forName方法来动态地加载类时，可以将类名作为参数传递给上述方法从而将指定类加载到JVM内存中，如果这个类在类路径中没有被找到，那么此时就会在运行时抛出ClassNotFoundException异常。<br><strong>解决该问题需要确保所需的类连同它依赖的包存在于类路径中，常见问题在于类名书写错误。</strong></p></li><li><p>另外还有一个导致ClassNotFoundException的原因就是：当一个类已经某个类加载器加载到内存中了，此时另一个类加载器又尝试着动态地从同一个包中加载这个类。<strong>通过控制动态类加载过程，可以避免上述情况发生。</strong></p></li></ul><p>NoClassDefFoundError产生的原因在于：</p><ul><li>如果JVM或者ClassLoader实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候却找不到类的定义。要查找的类在编译的时候是存在的，运行的时候却找不到了。这个时候就会导致NoClassDefFoundError。<strong>造成该问题的原因可能是打包过程漏掉了部分类，或者jar包出现损坏或者篡改。解决这个问题的办法是查找那些在开发期间存在于类路径下但在运行期间却不在类路径下的类。</strong></li></ul><h1 id="final、-finally、-finalize的不同"><a href="#final、-finally、-finalize的不同" class="headerlink" title="final、 finally、 finalize的不同"></a>final、 finally、 finalize的不同</h1><p>final可以用来修饰类、方法、变量，分别有不同的意义， final修饰的class代表不可以继承扩展， final的变量是不可以修改的，而final的方法也是不可以重写的。<br>finally则是Java保证重点代码一定要被执行的一种机制。我们可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接、保证unlock锁等动作。<br>finalize是基础类java.lang.Object的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。 fnalize机制现在已经不推荐使用，并且在JDK 9开始被标记为deprecated  </p><blockquote><p>为什么不推荐使用finalize？简单说，你无法保证fnalize什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。  </p><p>finally不执行的情况：1.system.exit(1)退出 2.无限循环 3.线程被杀死</p></blockquote><h1 id="强引用、软引用、弱引用、幻象引用的区别"><a href="#强引用、软引用、弱引用、幻象引用的区别" class="headerlink" title="强引用、软引用、弱引用、幻象引用的区别"></a>强引用、软引用、弱引用、幻象引用的区别</h1><p>在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用； Java中根据其生命周期的长短，将引用分为4类，不同的引用类型，主要体现的是对象不同的可达性状态和对垃圾收集的影响。</p><ol><li>强引用</li></ol><p>特点：我们平常典型编码Object obj &#x3D; new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足， JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。</p><ol start="2"><li>软引用</li></ol><p>特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收， Java虚拟机就会把这个软引用加入到与之关联的引用<br>队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。<br>应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><ol start="3"><li>弱引用</li></ol><p>特点：弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收， Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br>应用场景：弱应用同样可用于内存敏感的缓存。</p><ol start="4"><li>虚引用</li></ol><p>特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 fnalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span> ();<br><span class="hljs-type">PhantomReference</span> <span class="hljs-variable">pr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span> (object, queue);<br></code></pre></td></tr></table></figure><p>  程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。<br>  应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。    </p><h1 id="反射和动态代理"><a href="#反射和动态代理" class="headerlink" title="反射和动态代理"></a>反射和动态代理</h1><ol><li>关于反射</li></ol><p>反射机制是Java语言提供的一种基础功能，赋予程序在运行时自省的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。反射技术常用在各类通用框架开发中。因为为了保证框架的通用性，需要根据配置文件加载不同的对象或类，并调用不同的方法，这个时候就会用到反射——运行时动态加载需要加载的对象。</p><ol start="2"><li>动态代理</li></ol><p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装RPC调用、面向切面的编程（AOP）。实现动态代理的方式很多，比如JDK自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似ASM、 cglib（基于ASM）、 Javassist等   </p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2023/01/17/%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/01/17/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、知识"><a href="#一、知识" class="headerlink" title="一、知识"></a>一、知识</h1><p>链表并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用，链表分为：单链表、双链表、循环链表。</p><p>链表的插入和删除操作的时间复杂度： O(1) ，链表的随机访问的时间复杂度：O(n) 。</p><p>数组和链表的对比：</p><ol><li>插入、删除、随机访问对比</li></ol><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202301160420509.png" alt="image-20230116042030459"></p><ol start="2"><li>数组的缺点是大小固定，一经声明就要占用整块连续内存空间，链表本身没有大小的限制，天然地支持动态扩容。</li></ol><h1 id="二、应用"><a href="#二、应用" class="headerlink" title="二、应用"></a>二、应用</h1><h2 id="1-如何基于链表实现-LRU-缓存淘汰算法？"><a href="#1-如何基于链表实现-LRU-缓存淘汰算法？" class="headerlink" title="1. 如何基于链表实现 LRU 缓存淘汰算法？"></a>1. 如何基于链表实现 LRU 缓存淘汰算法？</h2><p>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的（或者越靠近尾部的为最新访问的）。</p><p>当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</p><p>如果此数据没有在缓存链表中，又可以分为两种情况：</p><ol><li><p>如果此时缓存未满，则将此结点直接插入到链表的头部；</p></li><li><p>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部；</p></li></ol><p>优化：引入散列表来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。</p><p>具体实现参考<strong>2.LRU缓存</strong>中的第三种方法（单链表+HashMap实现）</p><h2 id="2-LRU-缓存"><a href="#2-LRU-缓存" class="headerlink" title="2.LRU 缓存"></a>2.<a href="https://leetcode.cn/problems/lru-cache-lcci/">LRU 缓存</a></h2><ol><li>使用LinkedHashMap实现</li><li>双向链表+HashMap实现<ul><li>将最近查询的以及最近添加的放入链表的末尾，当链表超过最大长度时，删除头节点所指向的节点（即为最近最少使用的缓存）实现缓存的固定容量</li><li>使用HashMap可以直接判断出链表中是否存在该key的缓存</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-comment">//内部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> val;<br>        <span class="hljs-comment">//前驱节点</span><br>        ListNode pre;<br>        <span class="hljs-comment">//后继节点</span><br>        ListNode next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">()</span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-comment">//头节点、尾节点（对链表的操作更加通用）</span><br>    <span class="hljs-keyword">private</span> ListNode head, tail;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, ListNode&gt; map;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        head.next = tail;<br>        tail.pre = head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-comment">//查看是否存在缓存key</span><br>        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>            <span class="hljs-comment">//将该节点从链表中移除</span><br>            node.pre.next = node.next;<br>            node.next.pre = node.pre;<br>            <span class="hljs-comment">//将该节点添加到链表的末尾</span><br>            moveLast(node);<br>            <span class="hljs-keyword">return</span> node.val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        ListNode node;<br>        <span class="hljs-comment">//可以通过使用查询判断是否存在</span><br>        <span class="hljs-keyword">if</span> (get(key) != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//修改节点的值</span><br>            map.get(key).val = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//创建新的节点</span><br>        node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(key, value);<br>        <span class="hljs-comment">//添加入map</span><br>        map.put(key, node);<br>        <span class="hljs-comment">//移动到链表的末尾</span><br>        moveLast(node);<br>        <span class="hljs-comment">//判断缓存是否超出设置的容量</span><br>        <span class="hljs-keyword">if</span> (map.size() &gt; capacity) &#123;<br>            <span class="hljs-comment">//移除最近最少使用的缓存节点</span><br>            map.remove(head.next.key);<br>            head.next = head.next.next;<br>            head.next.pre = head;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//将节点添加到链表的末尾</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveLast</span><span class="hljs-params">(ListNode node)</span> &#123;<br>        node.pre = tail.pre;<br>        tail.pre.next = node;<br>        node.next = tail;<br>        tail.pre = node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>单链表+HashMap实现<ul><li>使用单链表，最近使用的缓存数据存放在链表的末尾，最近不使用的数据在链表的头部</li><li>hashmap存放key以及key缓存节点对应的前驱节点（key-&gt;其缓存节点的前驱节点）</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> val;<br>        ListNode next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">()</span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> ListNode head, tail;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, ListNode&gt; map;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        tail = head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> node.next;<br>        <span class="hljs-keyword">if</span> (cur != tail) &#123;<br>            <span class="hljs-comment">//从链表移除</span><br>            node.next = cur.next;<br>            <span class="hljs-comment">//修改map</span><br>            map.put(key, tail);<br>            map.put(cur.next.key,node);<br>            moveLast(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        ListNode node;<br>        <span class="hljs-comment">//查询是否存在该key</span><br>        <span class="hljs-keyword">if</span> (get(key) != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//修改该缓存节点的值</span><br>            map.get(key).next.val = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//创建新的节点</span><br>        node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(key, value);<br>        <span class="hljs-comment">//添加缓存数据，key-&gt;该缓存节点的前驱节点</span><br>        map.put(key, tail);<br>        <span class="hljs-comment">//移动到链表的末尾</span><br>        moveLast(node);<br>        <span class="hljs-keyword">if</span> (map.size() &gt; capacity) &#123;<br>            <span class="hljs-comment">//移除map中缓存数据</span><br>            map.remove(head.next.key);<br>            <span class="hljs-comment">//移除链表中的缓存节点</span><br>            head.next = head.next.next;<br>            <span class="hljs-comment">//修改map中的数据，head.next.next的前驱节点为head</span><br>            map.put(head.next.key, head);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//将节点添加到链表的末尾</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveLast</span><span class="hljs-params">(ListNode node)</span> &#123;<br>        tail.next = node;<br>        node.next = <span class="hljs-literal">null</span>;<br>        tail = node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-回文链表"><a href="#3-回文链表" class="headerlink" title="3.回文链表"></a>3.<a href="https://leetcode.cn/problems/aMhZSa/">回文链表</a></h2><ol><li>将链表中的字符串添加至集合中，使用双指针遍历集合判断回文</li><li>使用快慢指针找到链表的中点（链表长度为偶数则为第二个中间），将中点后的链表反转，再将反转链表与原链表dui’bi</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> reverse(slow);<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (node.val != head.val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            node = node.next;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> node;<br>        node = node.next;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> node;<br>            node = node.next;<br>            cur.next = head;<br>            head = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-反转链表"><a href="#4-反转链表" class="headerlink" title="4.反转链表"></a>4.<a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></h2><p>两种方法:</p><ol><li>遍历</li></ol><ul><li>引入头节点，遍历链表，将遍历得到的节点插入到头节点的后一个节点，最后得到的链表为反转链表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">//头节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-comment">//遍历链表</span><br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>            head = head.next;<br>            cur.next = first.next;<br>            first.next = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> first.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>递归</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">//判断是否为null或者为最后一个节点</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">//递归返回反转链表</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> reverseList(head.next);<br>        <span class="hljs-comment">//当前节点置于反转链表末尾</span><br>        head.next.next = head;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-环形链表"><a href="#5-环形链表" class="headerlink" title="5.环形链表"></a>5.<a href="https://leetcode.cn/problems/linked-list-cycle/">环形链表</a></h2><p>使用快慢指针，当链表不存在环时，当节点指向为null时结束，当链表存在环时，快指针和慢指针总会在环中相遇，当快指针和慢指针指向的节点相同时结束循环。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> hasCycle(ListNode head) &#123;<br>    <span class="hljs-comment">//慢指针</span><br>        ListNode slow = head;<br>        <span class="hljs-comment">//快指针</span><br>        ListNode fast = head;<br>        <span class="hljs-comment">//快指针不为null继续</span><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (fast.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//快指针每次经过两个节点</span><br>                fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            slow = slow.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-comment">//判断快慢指针是否相遇</span><br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-合并两个有序链表"><a href="#6-合并两个有序链表" class="headerlink" title="6.合并两个有序链表"></a>6.<a href="https://leetcode.cn/problems/merge-two-sorted-lists/">合并两个有序链表</a></h2><p>创建头节点简化操作，遍历list1和list2链表比较大小，当一个链表遍历完后即可将另一链表直接添加至头节点链表的末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-comment">//头节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//比较大小</span><br>            <span class="hljs-keyword">if</span> (list1.val &gt; list2.val) &#123;<br>                cur.next = list2;<br>                list2 = list2.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = list1;<br>                list1 = list1.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-comment">//将剩余的链表直接插入至头节点所在的链表末尾</span><br>        cur.next = list1 == <span class="hljs-literal">null</span> ? list2 : list1;<br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-删除链表的倒数第-N-个结点"><a href="#7-删除链表的倒数第-N-个结点" class="headerlink" title="7.删除链表的倒数第 N 个结点"></a>7.<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></h2><p>创建头节点（不创建需要对特殊情况进行处理，比如：删除头节点），使用双指针首先快指针现遍历n个节点然后两个指针一同遍历，当快指针指向null时慢指针位于要删除节点的前一节点，接下来进行删除操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>       <span class="hljs-comment">//创建头节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> first;<br>        <span class="hljs-comment">//遍历n个节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        slow.next = slow.next.next;<br>        <span class="hljs-keyword">return</span> first.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-链表的中间结点"><a href="#8-链表的中间结点" class="headerlink" title="8.链表的中间结点"></a>8.<a href="https://leetcode.cn/problems/middle-of-the-linked-list/">链表的中间结点</a></h2><p>使用快慢指针，1. 当链表长度为偶数时，快指针最终指向null时结束遍历，这时慢指针指向链表的第二个中间节点。2. 当链表长度为奇数时，快指针指向最后一个节点结束遍历，这时慢指针指向链表的中间节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言实现UDP服务器</title>
    <link href="/2022/12/28/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0UDP%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/12/28/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0UDP%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TCP-x2F-IP协议与Winsock网络编程接口"><a href="#1-TCP-x2F-IP协议与Winsock网络编程接口" class="headerlink" title="1 TCP&#x2F;IP协议与Winsock网络编程接口"></a>1 TCP&#x2F;IP协议与Winsock网络编程接口</h2><p>为了方便网络编程，20世纪90年代初，Microsoft联合其他几家公司共同制定了一-套Windows下的网络编程接口，即Winsock规范。它不是一种网络协议，而是-一套开放的、支持多种协议的Windows下的网络编程接口。Winsock可以访问很多种网络协议，可以把它当作﹒些协议的封装。现在的Winsock已经基本上实现了与协议无关。可以使用Winsock束调用多种协议的功能。</p><p>那么，Winsock和TCP&#x2F;IP协议到底有什么关系呢?实际上，Winsock就是TCP&#x2F;IP协议的种封装。你可以通过调用Winsock的接口函数来调用TCP&#x2F;IP的各种功能。例如，我们想用TCP&#x2F;IP协议发送数据，就可以使用Winsock的接口函数send()来调用TCP&#x2F;IP的发送数据功能,Winsock已经封装好了发送数据的功能。</p><h2 id="2-Winsock-的常用API"><a href="#2-Winsock-的常用API" class="headerlink" title="2 Winsock 的常用API"></a>2 Winsock 的常用API</h2><h3 id="2-1-WSAStartup函数"><a href="#2-1-WSAStartup函数" class="headerlink" title="2.1 WSAStartup函数"></a>2.1 WSAStartup函数</h3><p>WSAStartup函数的格式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">WSastartup</span><span class="hljs-params">( WORD wversionRequested,LPWSADATA <span class="hljs-number">1</span>pwSAData)</span>;<br></code></pre></td></tr></table></figure><p>程序在使用Socket之前必须调用WSAStartup函数。</p><ul><li><p>该函数的第一个参数指明程序请求使用的Socket版本，其中高位字节指明修订版本、低位字节指明主版本;</p></li><li><p>操作系统利用第二个参数返回请求的Socket的版本信息。当一个应用程序调用WSAStartup函数时，操作系统根据请求的Socket版本来搜索相应的Socket库、然后将找到的Socket库绑定到该应用程序中。以后应用程序就可以调用所请求的Socket库中的其他Socket函数了。</p></li></ul><p>该函数执行成功后返回0。</p><h3 id="2-2-socket函数"><a href="#2-2-socket函数" class="headerlink" title="2.2 socket函数"></a>2.2 socket函数</h3><p>socket函数的格式为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Socket <span class="hljs-title function_">socket</span><span class="hljs-params">( <span class="hljs-type">int</span> af, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol )</span>;<br></code></pre></td></tr></table></figure><p>应用程序调用socket函数来创建一个能够进行网络通信的套接字。</p><ul><li><p>第一个参数指定应用程序使用的通信协议的协议族，如果使用TCP&#x2F;IP协议族，则该参数置PF_INET，设置通信域(本地(PF_LOCAL),ipv4(PF_INET),ipv6(PF_INET6)。</p></li><li><p>第二个参数指定要创建的套接字类型（流套接字类型为SOCK_STREAM，数据报套接字类型为SOCK_DGRAM)。</p></li><li><p>第三个参数指定应用程序所使用的通信协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议。</p></li></ul><p>如果该函数调用成功，则返回新创建的套接字的描述符，如果失败则返回INVALID_SOCKET。套接字描述符是一个整数类型的值。每个进程的进程空间里都有一个套接字描述符表，该表中存放着套接字描述符和套接字数据结构的对应关系。该表用一个字段存放新创建的套接字的描述符，另一个字段存放套接字数据结构的地址，因此根据套接字描述符就可以找到其对应的套接字数据结构。</p><h3 id="2-3-bind函数"><a href="#2-3-bind函数" class="headerlink" title="2.3 bind函数"></a>2.3 bind函数</h3><p>bind函数的格式为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">( SOCKET s,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr FAR *name, <span class="hljs-type">int</span> namelen)</span>;<br></code></pre></td></tr></table></figure><p>当创建了一个Socket以后，套接字数据结构中有一个默认的IP地址和默认的端口号。一个服务程序必须调用bind函数来给Socket绑定一个IP地址和一个特定的端口号。客户程序一般不必调用bind函数来为其Socket绑定IP地址和端口号。该函数的第一个参数指定待绑定的Socket描述符;第二个参数指定一个sockaddr结构，该结构的定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span></span><br><span class="hljs-class">&#123;</span><br>u _short sa_family;<br><br><span class="hljs-type">char</span> sa_data[ <span class="hljs-number">14</span> ];<br>&#125;;<br></code></pre></td></tr></table></figure><p>sa_family指定地址族，对于TCP&#x2F;IP协议族的套接字，将其置AF_INET。当对TCP&#x2F;IP协议族的套接字进行绑定时，我们通常使用如下所示的另一个地址结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span>&#123;</span><br><br>  <span class="hljs-type">sa_family_t</span>     sin_family;   <span class="hljs-comment">//地址族（Address Family），也就是地址类型</span><br><br>  <span class="hljs-type">uint16_t</span>        sin_port;     <span class="hljs-comment">//16位的端口号</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span>  <span class="hljs-title">sin_addr</span>;</span>     <span class="hljs-comment">//32位IP地址    </span><br><br>  <span class="hljs-type">char</span>  sin_zero[<span class="hljs-number">8</span>];  <span class="hljs-comment">//不使用，一般用0填充</span><br> &#125;;<br></code></pre></td></tr></table></figure><p>其中，sin_family置AF_INET; sin_port指明端口号; sin_addr结构体中只有一个唯一的字段s_addr，它表示IP地址。该字段是一个整数，一般用函数inet_addr()把字符串形式的IP地址转换成无符号长整型的整数值后再赋给s_addr。我们用0来填充sin_zero数组，目的是让sockaddr_in结构的大小与sockaddr结构的大小一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span>&#123;<br>   <span class="hljs-type">in_addr_t</span>  s_addr;  <span class="hljs-comment">//32位的IP地址</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>s_addr 是一个整数，而IP地址是一个字符串，所以需要 inet_addr() 函数进行转换将一个无符号短整型数值转换为网络字节序，即大端模式。</p><h3 id="2-4-recvfrom函数"><a href="#2-4-recvfrom函数" class="headerlink" title="2.4 recvfrom函数"></a>2.4 recvfrom函数</h3><p>recefrom为无连接读函数，函数格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">int</span> buf_len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags,<span class="hljs-keyword">struct</span> sockaddr *from,<span class="hljs-type">int</span> fromlen)</span>;<br></code></pre></td></tr></table></figure><p>从UDP接收数据，返回实际接收的字节数，失败时返回-1</p><ul><li><p>Sockfd:套接字描述符</p></li><li><p>buf:指向内存块的指针</p></li><li><p>buf_len:内存块大小，以字节为单位</p></li><li><p>flags:一般为0</p></li><li><p>from:远端的地址，IP地址和端口号</p></li><li><p>fromlen:远端地址长度</p></li></ul><p>举例：recvfrom(sockfd,buf,8192,0,(struct sockaddr *)&amp;address, sizeof(address)); </p><h3 id="2-5-sendto函数"><a href="#2-5-sendto函数" class="headerlink" title="2.5 sendto函数"></a>2.5 sendto函数</h3><p>sendto为无连接函数，函数格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sendto</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * data, <span class="hljs-type">int</span> data_len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags, <span class="hljs-keyword">struct</span> sockaddr *remaddr,<span class="hljs-type">int</span> remaddr_len）</span><br></code></pre></td></tr></table></figure><p>基于UDP发送数据报，返回实际发送的数据长度，出错时返回－1</p><ul><li><p>sockfd:套接字描述符</p></li><li><p>data:指向要发送数据的指针</p></li><li><p>data_len:数据长度</p></li><li><p>flags:通常为0</p></li><li><p>remaddr:远端地址：IP地址和端口号</p></li><li><p>remaddr_len :地址长度</p></li></ul><p>举例：sendto(sockfd,buf,sizeof(buf),0,(struct sockaddr *)&amp;address, sizeof(address)); </p><h3 id="2-6-closesocket函数"><a href="#2-6-closesocket函数" class="headerlink" title="2.6 closesocket函数"></a>2.6 closesocket函数</h3><p>closesocket函数的格式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">closesocket</span> <span class="hljs-params">( SOCKET s )</span> ;<br></code></pre></td></tr></table></figure><p>closesocket函数用来关闭一个描述符为s的套接字。每个进程中都有一个套接字描述符表，表中的每个套接字描述符都与一个位于操作系统缓冲区中的套接字数据结构相对应，有可能有几个套接字描述符指向同一个套接字数据结构。套接字数据结构中专门有一个字段存放该结构被引用的次数，即有多少个套接字描述符指向该结构。closesocket函数如果执行成功就返回0，否则返回SOCKET_ERROR。</p><h3 id="2-7-WSACleanup函数"><a href="#2-7-WSACleanup函数" class="headerlink" title="2.7 WSACleanup函数"></a>2.7 WSACleanup函数</h3><p>WSACleanup函数的格式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">WSAcleanup</span> <span class="hljs-params">( <span class="hljs-type">void</span> )</span> ;<br></code></pre></td></tr></table></figure><p>应用程序在完成对请求的Socket库的使用后，要调用WSACleanup函数来解除与Socket库的绑定并且释放Socket库所占用的系统资源。</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3 代码实现"></a>3 代码实现</h2><h3 id="3-1-服务端代码实现"><a href="#3-1-服务端代码实现" class="headerlink" title="3.1 服务端代码实现"></a>3.1 服务端代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;winsock2.h&gt;</span><span class="hljs-comment">//为socket2.0  </span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 255</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span> &#123;<br><br><span class="hljs-comment">//返回一个无符号16位整形数，高八位（Socket修订版本）和低八位（主版本） </span><br>WORD socketVersion=MAKEWORD(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">//请求的Socket库，这个结构被用来存储被WSAStartup函数调用后返回的Windows Sockets数据</span><br>WSADATA wsadata;<br><br>SOCKET serveSocket;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serveAddr</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">clientAddr</span>;</span><br><br><span class="hljs-type">int</span> len=<span class="hljs-number">-1</span>;<br><br><span class="hljs-type">int</span> addrLen=<span class="hljs-keyword">sizeof</span>(clientAddr);<br><br><span class="hljs-comment">//缓冲数据</span><br><span class="hljs-type">char</span> receiveData[BUF_SIZE];<br><br><span class="hljs-type">char</span> sendData[BUF_SIZE];<br><br><span class="hljs-comment">//初始化socket库</span><br><span class="hljs-keyword">if</span>(WSAStartup(socketVersion,&amp;wsadata)!=<span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket库初始化失败\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//创建socket</span><br>serveSocket=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);<br><br><span class="hljs-keyword">if</span>(serveSocket==INVALID_SOCKET) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket服务器创建失败&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//设置地址类型、端口号、接收地址</span><br>serveAddr.sin_family=AF_INET;<br>serveAddr.sin_port=htons(<span class="hljs-number">15632</span>);<br><span class="hljs-comment">//监听本机的所有接口</span><br>serveAddr.sin_addr.S_un.S_addr= htonl(INADDR_ANY);<br><br><span class="hljs-comment">//socket绑定设置的IP和端口号</span><br><span class="hljs-keyword">if</span>(bind(serveSocket,(SOCKADDR*)&amp;serveAddr,<span class="hljs-keyword">sizeof</span>(serveAddr))==SOCKET_ERROR) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;绑定IP和端口出现问题\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;服务器开始运行\n&quot;</span>);<br><br><span class="hljs-comment">//接收数据</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>len=recvfrom(serveSocket,receiveData,BUF_SIZE<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,(SOCKADDR*)&amp;clientAddr,&amp;addrLen);<br><span class="hljs-keyword">if</span>(len&gt;<span class="hljs-number">0</span>) &#123;<br>receiveData[len]=<span class="hljs-number">0x00</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;接收到一个连接，IP地址为：%s \n&quot;</span>,inet_ntoa(clientAddr.sin_addr));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;客户端：%s \n&quot;</span>,receiveData);<br>&#125;<br><br><span class="hljs-comment">//响应数据</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;服务器：&quot;</span>);<br>fgets(sendData,<span class="hljs-keyword">sizeof</span>(sendData),<span class="hljs-built_in">stdin</span>);<span class="hljs-comment">//标准流 </span><br>sendData[<span class="hljs-built_in">strlen</span>(sendData)<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>; <br>sendto(serveSocket,sendData,<span class="hljs-built_in">strlen</span>(sendData),<span class="hljs-number">0</span>,(SOCKADDR*)&amp;clientAddr,addrLen);<br>&#125;<br><br>closesocket(serveSocket);<br>WSACleanup();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-客户端代码实现"><a href="#3-2-客户端代码实现" class="headerlink" title="3.2 客户端代码实现"></a>3.2 客户端代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;winsock2.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 255</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span> &#123;<br><br>WORD socketVersion=MAKEWORD(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><br>WSADATA wsadata;<br><br>SOCKET clientSocket;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serveAddr</span>;</span><br><br><span class="hljs-type">int</span> len=<span class="hljs-number">-1</span>;<br><br><span class="hljs-type">int</span> addrLen=<span class="hljs-keyword">sizeof</span>(serveAddr);<br><br><br><span class="hljs-comment">//缓冲数据</span><br><span class="hljs-type">char</span> receiveData[BUF_SIZE];<br><br><span class="hljs-type">char</span> sendData[BUF_SIZE];<br><br><span class="hljs-keyword">if</span>(WSAStartup(socketVersion,&amp;wsadata)!=<span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket库初始化失败\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//创建socket</span><br>clientSocket=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);<br><br><span class="hljs-keyword">if</span>(clientSocket==INVALID_SOCKET) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket客户端创建失败\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(argc==<span class="hljs-number">5</span>) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">clientAddr</span>;</span><br>clientAddr.sin_family=AF_INET;<br>clientAddr.sin_addr.S_un.S_addr=inet_addr(argv[<span class="hljs-number">2</span>]);<br>clientAddr.sin_port=htons(atoi(argv[<span class="hljs-number">3</span>]));<br><span class="hljs-keyword">if</span>(bind(clientSocket,(SOCKADDR*)&amp;clientAddr,<span class="hljs-keyword">sizeof</span>(clientAddr))==SOCKET_ERROR) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;绑定IP和端口出现问题\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>serveAddr.sin_family=AF_INET;<br>serveAddr.sin_port=htons(atoi(argv[<span class="hljs-number">5</span>]));<br>serveAddr.sin_addr.S_un.S_addr=inet_addr(argv[<span class="hljs-number">4</span>]);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//设置地址类型、端口号、接收地址</span><br>serveAddr.sin_family=AF_INET;<br>serveAddr.sin_port=htons(<span class="hljs-number">15632</span>);<br>serveAddr.sin_addr.S_un.S_addr=inet_addr(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">//收发数据</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-comment">//发送数据</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;客户端：&quot;</span>);<br>fgets(sendData,<span class="hljs-keyword">sizeof</span>(sendData),<span class="hljs-built_in">stdin</span>);<br>sendData[<span class="hljs-built_in">strlen</span>(sendData)<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-comment">//不再发送数据</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(sendData,<span class="hljs-string">&quot;bye&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send OK!\n&quot;</span>);<br><br><br>sendto(clientSocket,sendData,<span class="hljs-built_in">strlen</span>(sendData),<span class="hljs-number">0</span>,(SOCKADDR*)&amp;serveAddr,addrLen);<br><span class="hljs-comment">//接收数据</span><br>len=recvfrom(clientSocket,receiveData,BUF_SIZE<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,(SOCKADDR*)&amp;serveAddr,&amp;addrLen);<br><span class="hljs-keyword">if</span>(len&gt;<span class="hljs-number">0</span>) &#123;<br>receiveData[len]=<span class="hljs-number">0x00</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;服务器：%s \n&quot;</span>,receiveData);<br>&#125;<br><br>&#125;<br><br>closesocket(clientSocket);<br>WSACleanup();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-遇到的问题"><a href="#4-遇到的问题" class="headerlink" title="4 遇到的问题"></a>4 遇到的问题</h2><h3 id="4-1-undefined-reference-to’WSAStartup’相关编译错误"><a href="#4-1-undefined-reference-to’WSAStartup’相关编译错误" class="headerlink" title="4.1 undefined reference to’WSAStartup’相关编译错误"></a>4.1 undefined reference to’WSAStartup’相关编译错误</h3><p>打开dev-C++的工具-&gt;编译选项，添加-lws2_32命令即可解决，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202212281323563.png" alt="image-20221228132347388"></p><p><strong>参考资料</strong></p><p><a href="http://c.biancheng.net/view/2359.html">基于UDP的服务器端和客户端 (biancheng.net)</a></p><p><a href="https://blog.csdn.net/qq_31869107/article/details/81234785?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-81234785-blog-111029316.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-81234785-blog-111029316.pc_relevant_recovery_v2&utm_relevant_index=5">Dev C++的undefined reference to ‘__imp_htons’或codeclock的undefined reference to’WSAStartup to@8’相关编译器错</a></p>]]></content>
    
    
    <categories>
      
      <category>计网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
      <tag>UDP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eNSP的使用</title>
    <link href="/2022/12/04/eNSP%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/12/04/eNSP%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、eNSP软件是什么？"><a href="#一、eNSP软件是什么？" class="headerlink" title="一、eNSP软件是什么？"></a>一、eNSP软件是什么？</h1><p>eNSP(Enterprise Network Simulation Platform)是一款由华为提供的、可扩展的、图形化操作的网络仿真工具平台，主要对企业网络路由器、交换机进行软件仿真，完美呈现真实设备实景，支持大型网络模拟，让广大用户有机会在没有真实设备的情况下能够模拟演练，学习网络技术。</p><blockquote><p>以上解释来自于百度百科</p></blockquote><h1 id="二、eNSP软件安装"><a href="#二、eNSP软件安装" class="headerlink" title="二、eNSP软件安装"></a>二、eNSP软件安装</h1><h2 id="2-1-安装包"><a href="#2-1-安装包" class="headerlink" title="2.1 安装包"></a>2.1 安装包</h2><p>由于现在华为官网没有提供eNSP的安装包了，所以需要下载的同学应到网上寻找资源下载对应的版本，下载完之后进入安装界面，只需一直点击下一步即可，安装eNSP的时候会附带安装VirtualBox、Wireshark。</p><h2 id="2-2-安装遇到的坑"><a href="#2-2-安装遇到的坑" class="headerlink" title="2.2 安装遇到的坑"></a>2.2 安装遇到的坑</h2><p>由于个人找到的eNSP版本为1.2.00.510，其附带安装的VirtualBox（版本是5左右的）无法在Windows上运行，所以将其卸载后安装版本6的，但是eNSP不支持，最后看到一篇关于解决VirtualBox不兼容问题的博客，然后将其换为VirtualBox-5.2.44-139111-Win该版本后问题解决。</p><h1 id="三、eNSP的使用"><a href="#三、eNSP的使用" class="headerlink" title="三、eNSP的使用"></a>三、eNSP的使用</h1><h2 id="3-1-主页"><a href="#3-1-主页" class="headerlink" title="3.1 主页"></a>3.1 主页</h2><div align="center"><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211220146783.png" height="60%" width="80%"></div><p>上图所示即为eNSP打开的界面，上面为功能栏，左侧为一些实验器材，中间的样例即为自带可运行的示例，学习提供了关于eNSP的一些使用文档和介绍。</p><h2 id="3-2-拓扑页"><a href="#3-2-拓扑页" class="headerlink" title="3.2 拓扑页"></a>3.2 拓扑页</h2><div align="center"><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211220154865.png" height="60%" width="80%"></div><p>中间即为实验区域，左侧为实验的设备。</p><h3 id="PC配置"><a href="#PC配置" class="headerlink" title="PC配置"></a>PC配置</h3><div align="center"><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211220158012.png" height="40%" width="60%"></div><p>通过PC的配置页面进行IP地址、子网掩码、网关的配置，网关即为该PC连接的路由的IP地址，可以通过对路由器进行DHCP配置，选择DHCP自动分配IP地址。</p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><div align="center"><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211220204861.png" height="40%" width="40%"></div><p>一般常用的路由器即为AR2220、Router路由器，可用通过选择CLI或者双击路由器图标进入类似于DOS黑窗口中进行配置。首先sys进入然后通过 int  g0&#x2F;0&#x2F;0(端点号)选择对应端点，通过ip add ip地址 地址掩码设置该端点的ip地址。</p><h4 id="设置ripv2"><a href="#设置ripv2" class="headerlink" title="设置ripv2"></a>设置ripv2</h4><ol><li><p>对路由器进行配置：rip （进入rip协议的配置）</p></li><li><p>Version 2（选择RIP的版本）</p></li><li><p>Network 网络地址（与该路由直连的网络地址）</p></li><li><p>对相连的路由器都使用以上配置。</p></li><li><p>配置完成后使用dis ip routing-table命令查看路由表，表中存在rip协议的路由对应数据，即为配置成功</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202212041710885.png" alt="image-20221204171038773"></p><h4 id="设置DHCP"><a href="#设置DHCP" class="headerlink" title="设置DHCP"></a>设置DHCP</h4><ol><li><p>Dhcp enable开启DHCP服务</p></li><li><p>Ip pool pool1创建全局地址池pool1</p></li><li><p>getway-list 网关地址 设置分配的网关地址</p></li><li><p>network ip地址 mask 子网掩码 设置全局地址池的范围</p></li><li><p>dns-list 主要DNS 备用DNS 设置DNS</p></li><li><p>excluded-ip-address ip地址 ip地址 设置不参与动态分配的地址，可以是一个范围</p></li><li><p>再进入对应的接口，dhcp select global开启全局地址分配ip</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202212041712625.png" alt="image-20221204171236569"></p><h2 id="3-3-交换机"><a href="#3-3-交换机" class="headerlink" title="3.3 交换机"></a>3.3 交换机</h2><p>ensp中S5700交换机为三层交换机，你可以为它设置ip地址，若无需要可直接使用。</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>以上为本人完成计网作业的一些总结，希望可以帮助到大家。</p><p><strong>参考资料</strong></p><p><a href="https://blog.csdn.net/lushixuan12345/article/details/124227195">【eNSP】解决virtualbox不兼容&#x2F;无法运行问题_擅长开发Bug的Mr.NaCl的博客-CSDN博客</a></p><p><a href="https://www.bilibili.com/read/cv14351927">eNSP的DHCP的三种配置 - 哔哩哔哩 (bilibili.com)</a></p><p><a href="https://blog.csdn.net/weixin_48711866/article/details/121604408">华为ensp路由器动态RIP协议配置</a></p>]]></content>
    
    
    <categories>
      
      <category>计网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
      <tag>ensp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译及运行错误</title>
    <link href="/2022/11/16/%E7%BC%96%E8%AF%91%E5%8F%8A%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF/"/>
    <url>/2022/11/16/%E7%BC%96%E8%AF%91%E5%8F%8A%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="一、编译及运行出错"><a href="#一、编译及运行出错" class="headerlink" title="一、编译及运行出错"></a>一、编译及运行出错</h1><blockquote><p>在一次作业中，将java文件上传至Linux服务器，使用javac命令进行编译，之后用java命令运行编译文件，出现找不到主类，之后想在本地使用命令行运行查找问题，结果直接编译出错，故写下该篇文章记录问题。</p></blockquote><h2 id="1-运行出错"><a href="#1-运行出错" class="headerlink" title="1. 运行出错"></a>1. 运行出错</h2><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211162057891.png" alt="运行出错"></p><p>java程序在Linux运行错误原因：java文件中带有包名，编译后的class文件应该放在该包下，使用以下命令运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java 包名.类名<br></code></pre></td></tr></table></figure><h2 id="2-编译出错"><a href="#2-编译出错" class="headerlink" title="2. 编译出错"></a>2. 编译出错</h2><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211162059530.png" alt="image-20221116205933493"></p><ol><li>Java程序在编译的时候，需要使用JDK开发工具包中的JAVAC.EXE命令，而JDK开发工具包是国际版的，默认是对Unicode的编码格式的源文件进行编译操作。</li><li>因此其他编码格式的源文件需要先转为Unicode格式才能够进行编译。</li><li>在未指定源程序文件的编码格式的情况下，JDK会优先获取操作系统的file.encoding参数，然后JDK就把我们的JAVA源程序从file.encoding编码格式转化为JAVA内部默认的Unicode格式放到内存中。</li><li><strong>如果源文件的编码格式不是file.encoding，就会出现乱码-不能够正确对应的中文而报错。</strong></li><li>javac把转换后的Unicode格式的文件进行编译成class类文件，此时.class文件是Unicode编码的，它暂放在内存中。之后，JDK将此以Unicode编码编译后的.class文件保存到操作系统中形成我们见到的.class文件。</li></ol><p><strong>解决方法</strong>：</p><ol><li>将java文件以ASCII编码格式保存</li><li>使用以下命令进行java程序的编译</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">javac -encoding UTF-8 文件名.java<br></code></pre></td></tr></table></figure><p><strong>参考文章</strong></p><p><a href="https://blog.csdn.net/Tsing1644/article/details/107375558?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-5-107375558-blog-106419663.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-5-107375558-blog-106419663.pc_relevant_default&utm_relevant_index=9">解析java程序编译时编码GBK的不可映射字符的错误</a></p>]]></content>
    
    
    <categories>
      
      <category>问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA建立多级包</title>
    <link href="/2022/11/10/IDEA%E5%BB%BA%E7%AB%8B%E5%A4%9A%E7%BA%A7%E5%8C%85/"/>
    <url>/2022/11/10/IDEA%E5%BB%BA%E7%AB%8B%E5%A4%9A%E7%BA%A7%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="一、建立多级包"><a href="#一、建立多级包" class="headerlink" title="一、建立多级包"></a>一、建立多级包</h1><blockquote><p>由于本人隔一段时间就会遇到该问题并且每次都忘记方法需要查找资料，故写下该片博客记录</p></blockquote><h2 id="1-1-建立Package"><a href="#1-1-建立Package" class="headerlink" title="1.1 建立Package"></a>1.1 建立Package</h2><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101716505.png" alt="步骤一"></p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101717810.png" alt="步骤二"></p><p>建立多级package<strong>中间用.分割</strong></p><h2 id="1-2-建立Directionary"><a href="#1-2-建立Directionary" class="headerlink" title="1.2 建立Directionary"></a>1.2 建立Directionary</h2><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101719735.png" alt="步骤一"></p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101720925.png" alt="步骤二"></p><p>建立多级directionary<strong>中间用&#x2F;分割</strong>，<strong>不能使用.分割，使用.分割建立的为单级directionary</strong></p><h1 id="二、-解决多级包不分离问题"><a href="#二、-解决多级包不分离问题" class="headerlink" title="二、 解决多级包不分离问题"></a>二、 解决多级包不分离问题</h1><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101726557.png" alt="步骤一"></p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101728575.png" alt="步骤二"></p><p>取消选择：Compact Middle Packages，多级目录分离</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101729695.png" alt="步骤三"></p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
      <tag>问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2022/10/30/%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/10/30/%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一、反射机制"><a href="#一、反射机制" class="headerlink" title="一、反射机制"></a>一、反射机制</h1><p>反射机制允许程序在执行期借助Reflection API取得任何类的内部信息（比如成员变量、构造器、成员方法等）并能操作对象的属性和方法，反射在设计模式和框架底层都会用到。</p><p>加载完类之后，在堆中就会产生一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202210301944451.png" alt="三个阶段"></p><h2 id="1-1-Java反射机制可以完成"><a href="#1-1-Java反射机制可以完成" class="headerlink" title="1.1 Java反射机制可以完成"></a>1.1 Java反射机制可以完成</h2><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时得到任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ol><h2 id="1-2-反射主要的类"><a href="#1-2-反射主要的类" class="headerlink" title="1.2 反射主要的类"></a>1.2 反射主要的类</h2><p>java.lang.Class 代表一个类，Class对象表示某个类加载后在堆中的对象</p><p>java.lang.reflect.Method 代表类的方法，Method对象表示某个类的方法</p><p>java.lang.reflect.Field 代表类的成员变量，Field对象表示某个类的成员变量</p><p>java.lang.reflect.Constructor 代表类的构造方法，Constructor对象表示某个类的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//使用反射解决</span><br>    <span class="hljs-comment">//加载类，返回Class类型的对象cls</span><br>    Class cls=Class.forName(<span class="hljs-string">&quot;类的全限定名&quot;</span>);<br>    <span class="hljs-comment">//通过cls获取对象的实例，无参构造器创建</span><br>    Object o=cls.newInstance();<br>    System.out.println(o.getClass());<br>    <span class="hljs-comment">//获取方法对象，将方法看做对象（万物皆对象）</span><br>    <span class="hljs-comment">//只能获取public修饰的方法</span><br>    Method method1=cls.getMethod(<span class="hljs-string">&quot;方法名&quot;</span>);<br>    <span class="hljs-comment">//通过method1调用方法</span><br>    System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>    <span class="hljs-comment">//传统：对象.方法()，反射机制 方法.invoke()</span><br>    method1.invoke(o);<br><br>    <span class="hljs-comment">//Field对象表示表示类的属性</span><br>    <span class="hljs-comment">//getField只能获取public修饰的属性</span><br>    Field nameField=cls.getField(<span class="hljs-string">&quot;属性名&quot;</span>);<br>    System.out.println(nameField.get(o));<br><br>    <span class="hljs-comment">//Constructor对象表示构造器，只能获取public修饰的构造器</span><br>    <span class="hljs-comment">//若无指定类型，获取无参构造器对象</span><br>    Constructor constructor=cls.getConstructor();<br>    System.out.println(constructor);<br><br>    <span class="hljs-comment">//获取有参构造器对象</span><br>    Constructor constructor1=cls.getConstructor(String.class);<br>    System.out.println(constructor1);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-反射优点和缺点"><a href="#1-3-反射优点和缺点" class="headerlink" title="1.3 反射优点和缺点"></a>1.3 反射优点和缺点</h2><p>优点：可以动态的创建和使用对象，使用领灵活，没有反射机制，框架技术失去底层支撑</p><p>缺点：使用反射基本是解释执行，对执行速度有影响</p><h2 id="1-4-反射调用优化"><a href="#1-4-反射调用优化" class="headerlink" title="1.4 反射调用优化"></a>1.4 反射调用优化</h2><p>Method、Field、Constructor对象都有setAccessible()方法，其作用是启动和禁用访问安全检查的开关，参数为true表示反射的对象在使用时取消访问检查，提高反射效率。参数值为false表示反射的对象执行访问检查。</p><h1 id="二、Class类"><a href="#二、Class类" class="headerlink" title="二、Class类"></a>二、Class类</h1><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/image-20221030145407804.png" alt="Class类图"></p><ol><li>如图，Class也是类，继承Object类</li><li>Class类对象不是new出来的，而是系统创建的</li><li>对于某个类的Class类对象，在内存中只有一份，类只加载一次</li><li>每个类的实例都会记得自己由哪个Class实例所生成的</li><li>通过Class的一系列API可以完整的得到一个类的完整结构</li><li>Class对象存放在堆中</li><li>类的字节码二进制数据，放在方法区的，有的地方称为类的元数据（包含方法代码、变量名、方法名、访问权限等）</li></ol><h2 id="2-1-Class类的常用方法"><a href="#2-1-Class类的常用方法" class="headerlink" title="2.1 Class类的常用方法"></a>2.1 Class类的常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;<br>    <span class="hljs-comment">//需要通过反射创建的类的全限定名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">classFullPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;base.reflection.pojo.Cat&quot;</span>;<br>    <span class="hljs-comment">//获取Cat类对应的Class对象</span><br>    <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(classFullPath);<br>    <span class="hljs-comment">//显示cls对象是哪个类的Class对象</span><br>    System.out.println(cls);<br>    <span class="hljs-comment">//输出cls运行类型</span><br>    System.out.println(cls.getClass());<br>    <span class="hljs-comment">//得到包名</span><br>    System.out.println(cls.getPackage().getName());<br>    <span class="hljs-comment">//得到全类名</span><br>    System.out.println(cls.getName());<br>    <span class="hljs-comment">//通过cls创建对象实例</span><br>    <span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> (Cat) cls.newInstance();<br>    System.out.println(cat);<br>    <span class="hljs-comment">//获取对象属性</span><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> cls.getField(<span class="hljs-string">&quot;age&quot;</span>);<br>    System.out.println(age.get(cat));<br>    <span class="hljs-comment">//通过反射给属性赋值</span><br>    age.set(cat, <span class="hljs-number">20</span>);<br>    <span class="hljs-comment">//获取所有public修饰的属性</span><br>    Field[] fields = cls.getFields();<br>    <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>        System.out.println(field);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-获取Class类对象的方法"><a href="#2-2-获取Class类对象的方法" class="headerlink" title="2.2 获取Class类对象的方法"></a>2.2 获取Class类对象的方法</h2><ol><li>已知一个类的全类名，而且类在类路径下，可通过Class的静态方法forName()获取。应用场景：多用于配置文件、读取类的全路径，加载类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;类的全路径&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高。应用场景：多用于参数传递</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls2=Cat.class;<br></code></pre></td></tr></table></figure><ol start="3"><li>已知某个类的实例，调用该实例的getClass()方法获取Class对象。应用场景：通过创建好的对象，获取Class对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls3=cat.getClass();<br></code></pre></td></tr></table></figure><ol start="4"><li>通过类加载器创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassLoader cl=对象.getClass().getClassLoader();<br>Class cls4=cl.loadClass(<span class="hljs-string">&quot;类的全类名&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="5"><li>基本数据类型（八种）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls=基本数据类型.class<br></code></pre></td></tr></table></figure><ol start="6"><li>基本数据类型对应的包装类，可以通过.TYPE得到Class对象(获取的是基本数据类型的Class对象)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls=包装类.TYPE<br></code></pre></td></tr></table></figure><blockquote><p>相同的基本类型和包装类.TYPE获取的Class类对象是同一个</p></blockquote><h2 id="2-3-具有Class对象的类型"><a href="#2-3-具有Class对象的类型" class="headerlink" title="2.3 具有Class对象的类型"></a>2.3 具有Class对象的类型</h2><ol><li>外部类、成员内部类、静态内部类、局部内部类、匿名内部类</li><li>interface：接口</li><li>数组</li><li>enum：枚举</li><li>annotation：注解</li><li>基本数据类型</li><li>void</li></ol><h1 id="三、类加载"><a href="#三、类加载" class="headerlink" title="三、类加载"></a>三、类加载</h1><p>反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载</p><ol><li>静态加载：编译时加载相关的类，如果不存在则报错，依赖性太强</li><li>动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，则不报错，降低了依赖性</li></ol><p><strong>类的加载时机</strong></p><ul><li>当创建对象时（静态加载）</li><li>当子类被加载时，父类也加载（静态加载）</li><li>调用类中的静态成员时（静态加载）</li><li>通过反射（动态加载）</li></ul><p><strong>类的加载过程</strong></p><p>java源码编译为字节码文件进行类的加载（类的加载分为三个阶段，如图），类加载后内存布局情况：类的字节码（二进制数据）存放于方法区，类的Class对象存放于堆区。</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202210301945424.png" alt="类的加载过程"></p><h2 id="3-1-加载阶段"><a href="#3-1-加载阶段" class="headerlink" title="3.1 加载阶段"></a>3.1 加载阶段</h2><p>JVMZ在该阶段的主要目的是将字节码从不同的数据源（可能是class文件、也可能是jar包，甚至网络）转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</p><h2 id="3-2-连接阶段"><a href="#3-2-连接阶段" class="headerlink" title="3.2 连接阶段"></a>3.2 连接阶段</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ol><li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li><li>包括：文件格式验证、元数据验证、字节码验证和符号引用验证</li><li>可以使用-Xverify:none参数关闭大部分的类验证措施，缩短虚拟机加载的时间</li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>JVM会在该阶段对静态变量，分配内存并默认初始化。这些变量所使用的内存都将在方法去中进行分配</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>虚拟机将常量池内的符号引用替换为直接引用的过程</p><h2 id="3-3-初始化"><a href="#3-3-初始化" class="headerlink" title="3.3 初始化"></a>3.3 初始化</h2><ol><li>到初始化阶段才真正开始执行类中定义的Java程序代码，此阶段是执行<clinit>()方法的过程</li><li><clinit>()方法由编译器按语句在源文件中出现的顺序，依次自动收集类中所有的静态变量的赋值动作和静态代码块中的语句，并进行合并。</li><li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁，同步。如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。</li></ol><h1 id="四、反射相关方法的使用"><a href="#四、反射相关方法的使用" class="headerlink" title="四、反射相关方法的使用"></a>四、反射相关方法的使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">public</span> Integer id;<br>    <span class="hljs-keyword">private</span> String address;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(Integer id, String address)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(Integer id)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;编号为：&quot;</span>+id+<span class="hljs-string">&quot;的汽车开始运行&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restart</span><span class="hljs-params">(String address)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;原产地为：&quot;</span>+address+<span class="hljs-string">&quot;的汽车重启&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Car&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, address=&#x27;&quot;</span> + address + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class cls=Class.forName(<span class="hljs-string">&quot;base.reflection.pojo.Car&quot;</span>);<br><br>    <span class="hljs-comment">//无参构造获取car实例</span><br>    Object o=cls.newInstance();<br>    System.out.println(o);<br>    System.out.println(Integer.class);<br>    <span class="hljs-comment">//通过public修饰的构造器创建对象</span><br>    Constructor constructor=cls.getConstructor(Integer.class);<br>    Object o1=constructor.newInstance(<span class="hljs-number">126</span>);<br>    System.out.println(o1);<br>    <span class="hljs-comment">//通过private修饰的构造器创建对象</span><br>    Constructor constructor1=cls.getDeclaredConstructor(Integer.class,String.class);<br>    <span class="hljs-comment">//未设置为true，则不能修改或使用私有属性和方法（下同）</span><br>    constructor1.setAccessible(<span class="hljs-literal">true</span>);<br>    Object o2=constructor1.newInstance(<span class="hljs-number">100</span>,<span class="hljs-string">&quot;新西兰&quot;</span>);<br>    System.out.println(o2);<br><br><br>    <span class="hljs-comment">//修改o的public修饰的属性</span><br>    Field fieldId=cls.getField(<span class="hljs-string">&quot;id&quot;</span>);<br>    fieldId.set(o,<span class="hljs-number">123</span>);<br>    <span class="hljs-comment">//修改o的private修饰的属性</span><br>    Field fieldAddress=cls.getDeclaredField(<span class="hljs-string">&quot;address&quot;</span>);<br>    fieldAddress.setAccessible(<span class="hljs-literal">true</span>);<br>    fieldAddress.set(o,<span class="hljs-string">&quot;冰岛&quot;</span>);<br>    System.out.println(o);<br><br>    <span class="hljs-comment">//调用o的方法</span><br>    Method methodStart=cls.getMethod(<span class="hljs-string">&quot;start&quot;</span>,Integer.class);<br>    methodStart.invoke(o,<span class="hljs-number">6</span>);<br>    <span class="hljs-comment">//调用o的private的方法</span><br>    Method methodRestart=cls.getDeclaredMethod(<span class="hljs-string">&quot;restart&quot;</span>,String.class);<br>    methodRestart.setAccessible(<span class="hljs-literal">true</span>);<br>    methodRestart.invoke(o,<span class="hljs-string">&quot;英国&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>视频资料</strong>：<a href="https://www.bilibili.com/video/BV1g84y1F7df/?from=search&seid=12408684664800836462&spm_id_from=333.337.0.0&vd_source=8e40d0a91b994e176587f5593e189b6a">【韩顺平讲Java】Java反射专题</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云服务器安装Redis</title>
    <link href="/2022/10/25/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Redis/"/>
    <url>/2022/10/25/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="一、安装Redis"><a href="#一、安装Redis" class="headerlink" title="一、安装Redis"></a>一、安装Redis</h2><ol><li>从redis的官网下载redis的安装包，redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></li><li>将redis的安装包通过Xftp上传到云服务上，自己选择一个文件夹存放redis安装包并进行解压</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xzf redis-7.0.0.tar.gz<br></code></pre></td></tr></table></figure><p>解压后如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/image-20221020134406224.png" alt="image-20221020134406224"></p><ol start="3"><li>Redis是基于C语言编写的，需要安装Redis所需要的gcc依赖，使用如下命令安装依赖</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum install -y gcc tcl<br></code></pre></td></tr></table></figure><ol start="4"><li>进入解压后的redis目录,运行编译命令,redis默认的安装路径是在 <code>/usr/local/bin</code>目录下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">make &amp;&amp; make install<br></code></pre></td></tr></table></figure><h2 id="二、开启远程连接"><a href="#二、开启远程连接" class="headerlink" title="二、开启远程连接"></a>二、开启远程连接</h2><ol><li>先找到redis.conf文件，将文件中的bind 127.0.0.1 -::1注释，不然只允许127.0.0.1连接，如下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#bind 127.0.0.1 -::1</span><br></code></pre></td></tr></table></figure><blockquote><p>bind ip是将指定的ip设置为redis的对外开放地址</p></blockquote><ol start="2"><li>将daemonize no修改为damemonize yes，即可后台运行redis</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">daemonize <span class="hljs-built_in">yes</span> <br></code></pre></td></tr></table></figure><ol start="3"><li>查找 # requirepass foobared，将注释去掉，设置连接密码</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">requirepass</span> 连接密码<br></code></pre></td></tr></table></figure><ol start="4"><li>启动redis</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-server redis.conf<br></code></pre></td></tr></table></figure><ol start="5"><li>本地连接redis成功<br><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/image-20221020140807427.png" alt="image-20221020140807427"></li></ol>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
