<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2023/01/23/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/01/23/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java版本划分"><a href="#Java版本划分" class="headerlink" title="Java版本划分"></a>Java版本划分</h1><ol><li><strong>Java SE</strong>-标准版，主要用于普通PC、工作站的Java控制台或桌面程序的基础开发</li><li><strong>Java ME</strong>-微型版，用于移动设备、嵌入式设备上的Java应用程序开发。</li><li><strong>Java EE</strong>-企业版，用于开发、部署和管理企业级、可扩展的大型软件或Web应用。</li></ol><blockquote><p>J2SE、J2ME、J2EE与Java SE、Java ME、Java EE的关系？</p><p>答：Java5.0版本后，J2SE、J2EE、J2ME分别更名为Java SE、Java EE、Java ME，由于习惯的原因，我们依然称之为J2SE、J2EE、J2ME。</p></blockquote><h1 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h1><ol><li>简单性：Java衍生于C&#x2F;C++，但它略去了C&#x2F;C++中学习起来比较难的多继承、指针等概念，并通过自动垃圾回收机制大大简化了程序员的内存管理工作，所以Java语言学习起来更简单，使用起来也更方便。</li><li>面向对象：Java是一种面向对象的编程语言。</li><li>分布式：Java是面向网络的语言，通过它提供的类库可以处理TCP&#x2F;IP协议，用户可以通过URL地址在网络上很方便地访问其他对象。</li><li>健壮性：Java非常强调早期的问题检测、后期动态的检测，以及消除容易出错的情况，其采用的指针模型可以消除重写内存和损坏数据的可能性。</li><li>安全性：Java不支持指针，一切对内存的访问都必须通过对象实例来完成，有效的防止黑客使用欺骗手段访问对象的私有成员，同时也避免由于指针操作导致程序或系统崩溃。</li><li>可移植性：Java并不依赖平台，用Java编写的程序可以移植到不同的操作系统上。</li><li>解释型：Java解释器可以在任何移植了解释器的机器上直接执行Java字节码。</li><li>高性能：字节码可以（在运行时）动态地转换成对应运行这个应用地特定CPU地机器码。（即时编译器可以监控哪些代码频繁执行，并优化这些代码提高速度）</li><li>多线程：Java支持并发程序设计，它可以同时执行多个程序，能处理不同任务。</li><li>动态性：库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。</li></ol><h1 id="JDK、JRE、JVM的区别"><a href="#JDK、JRE、JVM的区别" class="headerlink" title="JDK、JRE、JVM的区别"></a>JDK、JRE、JVM的区别</h1><p> JDK（ Java Development Kit ），Java开发工具包，提供了编译、运行Java程序所需要的各种工具 ，除了包含JRE以外还包含了开发Java程序所必须的命令工具。</p><p> JRE（ Java Runtime Environment），Java运行环境，主要包含两个部分：JVM和Java系统类库。所有的Java 程序都要在JRE下才能运行。普通用户需要运行已开发好的Java程序，只需要安装JRE即可。</p><p>JVM（ Java Virtual Mechinal ），Java虚拟机，负责加载、执行字节码文件(.class)，每种类型的操作系统都有一种对应的JVM，JVM屏蔽了底层操作系统的差异，使Java程序能够做到”一次编写，多处运行“。</p><blockquote><p>JDK&#x3D;JRE+编译、运行等命令工具</p><p>JRE&#x3D;JVM+Java系统类库</p></blockquote><h1 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h1><p>switch-case语句中，case的标签可以是：</p><ul><li>类型为char、byte、short或int的常量表达式（能自动转为int的类型，否则必须进行强制类型转换）</li><li>枚举常量</li><li>从Java7开始，case标签还可以是字符串字面量</li></ul><h1 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h1><p>重载：同一个方法对于输入的数据不同，做出不同的响应</p><ul><li>方法名相同</li><li>形参不同：数据类型不同或参数顺序不同</li><li>访问修饰符、返回类型不做要求</li></ul><p>重写：当子类继承父类的方法需，当输入的数据相同需要做出不同于父类的响应时，覆盖父类的方法</p><ul><li>方法名相同、参数相同</li><li>抛出的异常小于等于父类抛出的异常、返回的类型与父类返回类型相同或为其子类（void、基本类型不能被修改）</li><li>访问修饰符大于等于父类</li></ul><blockquote><p>静态方法、构造方法不能被重写，重载为编译期、重写为运行期</p></blockquote><h1 id="String中compareTo-与equals-的区别"><a href="#String中compareTo-与equals-的区别" class="headerlink" title="String中compareTo()与equals()的区别"></a>String中compareTo()与equals()的区别</h1><p>int compareTo(String other)：按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0</p><p>boolean equals(Object other)：如果字符串与other相等，返回true</p><h1 id="Comparator和Comparable的区别"><a href="#Comparator和Comparable的区别" class="headerlink" title="Comparator和Comparable的区别"></a>Comparator和Comparable的区别</h1><p>comparable接口出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</p><p>comparator接口出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</p><blockquote><p>Comparator和Comparable一般都用于实现排序，如：Collections.sort(List<T> list, Comparator&lt;? super T&gt; c) 方法可以通过传入Comparator实现类来自定义排序。</p></blockquote><h1 id="基本类型和包装类的区别"><a href="#基本类型和包装类的区别" class="headerlink" title="基本类型和包装类的区别"></a>基本类型和包装类的区别</h1><ul><li>成员变量为基本类型会有默认值不为null，包装类型默认默认值为null</li><li>包装类型可用于泛型，基本类型不能用于泛型</li><li>基本数据类型占用空间更小</li><li>基本类型的局部变量存在于虚拟机栈中，基本类型的成员变量存在于堆中，包装类型属于对象类型，基本存在于堆中</li></ul><blockquote><p>在Java 5中，引入了自动装箱（ 调用包装类的valueOf() ）和自动拆箱（ 调用xxxValue() ）功能， Java可以根据上下文，自动进行转换，极大地简化了相关编程。</p><p>在Java 5中新增了静态工厂方法valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进：Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。 </p></blockquote><h1 id="面向对象与面向过程的区别"><a href="#面向对象与面向过程的区别" class="headerlink" title="面向对象与面向过程的区别"></a>面向对象与面向过程的区别</h1><p>主要为解决问题的方式不同</p><ul><li>面向过程会将解决问题的过程拆成一个个方法，通过执行一个个方法解决问题</li><li>面向对象会抽象出对象，通过对象执行方法的方式解决问题</li></ul><h1 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h1><ol><li><p>封装：把一个对象的属性隐藏在对象内部，不允许外部对象直接访问对象的属性，但是可以提供一些可以被外界访问的方法来操作属性。</p></li><li><p>继承：使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</p></li><li><p>多态：一个对象具有多种状态，具体表现为父类指向子类实例</p></li></ol><blockquote><p>通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。子类拥有父类所有属性和方法（包括私有），但是父类中的私有属性和方法不能访问。</p></blockquote><h1 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h1><p>相同点：</p><ul><li>不能被实例化</li><li>可以包含抽象方法</li><li>可以有默认的实现方法</li></ul><p>不同点：</p><ul><li>接口主要用于对类的行为进行约束，让实现类具有特定的行为（方法）。抽象类主要用于代码的复用，定义类之间的关系</li><li>一个类可以实现多个接口，但只能继承一个类</li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法</li><li>接口中的成员变量为public static final 类型，不能被修改且必须有初始值。抽象类的成员变量可以为各种类型</li></ul><blockquote><p>接口中的抽象方法为public abstract、抽象类中抽象方法为 public 或 protected </p></blockquote><h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><p>浅拷贝：在堆中创建一个新的对象，当原对象内部的属性为引用类型时，浅拷贝直接复制其引用地址，拷贝对象和原对象的内部属性指向同一个内部对象。</p><p>深拷贝：深拷贝会复制整个对象包括内部引用类型属性所引用的对象。</p><h1 id="Object中常见的方法"><a href="#Object中常见的方法" class="headerlink" title="Object中常见的方法"></a>Object中常见的方法</h1><ol><li>equals比较两个对象内存地址是否相等</li><li>hashCode  返回对象的hash码（int整数）</li><li>toString 返回类名字的哈希码的16进制字符串</li><li>wait   暂停线程</li><li>notify  唤醒在一个在该对象中暂停的线程</li><li>notifyAll  唤醒在该对象中暂停的所有线程</li><li>getClass 获取该类的类对象</li><li>finalize  垃圾回收时执行的方法</li></ol><h1 id="为什么重写equals-方法必须要重写hashCode-方法？"><a href="#为什么重写equals-方法必须要重写hashCode-方法？" class="headerlink" title="为什么重写equals()方法必须要重写hashCode()方法？"></a>为什么重写equals()方法必须要重写hashCode()方法？</h1><p>两个对象相等则其hash值相等，通过equals方法判断两个对象相等则其hashCode值相等。当重写equals不重写hashCode时，可能会出现equals判断两个对象相等，但其hash值不相等。</p><h1 id="String为什么是不可变的？"><a href="#String为什么是不可变的？" class="headerlink" title="String为什么是不可变的？"></a>String为什么是不可变的？</h1><ol><li>保存字符串的数组被final修饰且为私有的，String类并没有提供修改这个字符串数组中值的方法</li><li>String被final修饰不能被继承避免了子类破坏String的不可变。</li></ol><h1 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h1><p>String是Java语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的Immutable类，被声明成为final class，所有属性也都是final的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的String对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。</p><p>StringBufer是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用append或者add方法，把字符串添加到已有序列的末尾或者指定位置。 StringBufer本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是StringBuilder。</p><p>StringBuilder是Java 1.5中新增的，在能力上和StringBufer没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。 </p><blockquote><p>为了实现修改字符序列的目的， StringBufer和StringBuilder底层都是利用可修改的（char， JDK 9以后是byte）数组，二者都继承了AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了synchronized。</p><p>构建时初始字符串长度为16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是16)</p></blockquote><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型，使用泛型后从容器中取出对象编译器自动转换对象类型。</p><h1 id="对Java平台的理解"><a href="#对Java平台的理解" class="headerlink" title="对Java平台的理解"></a>对Java平台的理解</h1><ol><li>Java语言本身、JDK中提供的核心类库和相关工具</li></ol><ul><li>面向对象（封装、继承、多态）</li><li>跨平台（一次书写到处运行，跨平台能力）</li><li>语言（泛型、Lambda）</li><li>类库（集合、网络、并发、IO&#x2F;NIO）</li><li>工具（基本的编译工具、虚拟机性能诊断工具）</li></ul><ol start="2"><li>Java虚拟机</li></ol><ul><li>垃圾收集(GC)，Java通过垃圾收集器回收分配内存，程序员不需要自己操心内存的分配和回收</li><li>对于虚拟机而言，只要是符合规范的字节码，它们都能被加载执行，当然，能正常运行的程序光满足这点是不行的，程序本身需要保证在运行时不出现异常。所以， Scala、 Kotlin、 Jython等语言也可以跑在虚拟机上。</li></ul><h1 id="Java是解释执行的吗？"><a href="#Java是解释执行的吗？" class="headerlink" title="Java是解释执行的吗？"></a>Java是解释执行的吗？</h1><p>Java是解释执行这句话不太准确，首先Java源代码通过Javac编译为字节码，通过 Java虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。但是常见的JVM都提供了JIT编译器(动态编译器)，JIT能过在运行时将热点代码编译成机器码，这种情况下这部分热点代码属于编译执行，而不是解释执行。Java 9提供的AOT编译器可以直接将所有代码编译成机器码执行。 </p><blockquote><p>Java采用的是解释和编译混合的模式。它首先通过javac将源码编译成字节码文件class.然后在运行的时候通过解释器或者JIT将字节码转换成最终的机器码。<br>只是用解释器的缺点：抛弃了JIT可能带来的性能优势。如果代码没有被JIT编译的话，再次运行时需要重复解析。<br>只用JIT的缺点：<br>需要将全部的代码编译成本地机器码。要花更多的时间， JVM启动会变慢非常多；<br>增加可执行代码的长度（字节码比JIT编译后的机器码小很多），这将导致页面调度，从而降低程序的速度。<br>有些JIT编译器的优化方式，比如分支预测，如果不进行profling，往往并不能进行有效优化。<br>因此， HotSpot采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。 JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。<br>JDK 9引入了一种新的编译模式AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。 JDK支持分层编译和AOT协作使用。<br>注： JIT为方法级，它会缓存编译过的字节码在CodeCache中，而不需要被重复解释  </p></blockquote><h1 id="为什么不全部使用-AOT-呢？"><a href="#为什么不全部使用-AOT-呢？" class="headerlink" title="为什么不全部使用 AOT 呢？"></a>为什么不全部使用 AOT 呢？</h1><p>这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p><h1 id="对于一次编译，到处运行的理解"><a href="#对于一次编译，到处运行的理解" class="headerlink" title="对于一次编译，到处运行的理解"></a>对于一次编译，到处运行的理解</h1><p>一次编译，到处运行说的是Java语言跨平台的特性，程序从源代码到运行经过三个阶段：编码-编译-运行，Java在编译阶段体现了跨平台的特点，编译的大概过程：首先将Java源代码通过Javac编译为.CLASS文件字节码，该字节码文件即为可到处运行的文件，然后字节码会被转变为机器码，这是由JVM来执行的，即Java的第二次编译。</p><p>到处运行的关键和前提就是JVM，因为在第二次编译中JVM起着关键作用。在可以运行Java虚拟机的地方都内含着一个JVM操作系统，从而使Java提供了各种不同平台上的虚拟机制、屏蔽不同操作系统之间的差异，因此实现了“到处运行”的效果 。 </p><blockquote><p>其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编译，到处运行这样的效果。</p></blockquote><h1 id="Exception和Error的区别"><a href="#Exception和Error的区别" class="headerlink" title="Exception和Error的区别"></a>Exception和Error的区别</h1><p>Exception和Error都是继承了Throwable类，在Java中只有Throwable类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。Exception和Error体现了Java平台设计者对不同异常情况的分类。 </p><ul><li><p>Error：系统错误类，是指在正常情况下，不大可能出现的情况，代表程序运行时Java系统内部错误，一般由硬件或操作系统引发。既然是非正常情况，所以不便于也不需要捕获，常见的比如OutOfMemoryError之类，都是Error的子类。</p></li><li><p>Exception：异常类，是程序正常运行中，可以预料的意外情况，应该被捕获并进行相应处理。它包含子类RuntimeException、IOException异常，RuntimeException类表示Java程序运行时产生的异常，如数组下标越界、对象类型强制转换错误、空指针等，IOException类及其子类表示各种I&#x2F;O错误。</p></li></ul><blockquote><p>异常又分为检查（checked）异常和非检查（unchecked）异常，检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。Error和RuntimeException类及其子类为非检查异常，IOException类及其子类为检查异常。</p><p>非检查异常就是所谓的运行时异常，类似 NullPointerException、 ArrayIndexOutOfBoundsException之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。  </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202301011811770.png" alt="image-20230101181148657"></p><h1 id="NoClassDefFoundError和ClassNotFoundException的区别"><a href="#NoClassDefFoundError和ClassNotFoundException的区别" class="headerlink" title="NoClassDefFoundError和ClassNotFoundException的区别"></a>NoClassDefFoundError和ClassNotFoundException的区别</h1><p>ClassNotFoundException的产生原因主要是：</p><ul><li><p>Java支持使用反射方式在运行时动态加载类，例如使用Class.forName方法来动态地加载类时，可以将类名作为参数传递给上述方法从而将指定类加载到JVM内存中，如果这个类在类路径中没有被找到，那么此时就会在运行时抛出ClassNotFoundException异常。<br><strong>解决该问题需要确保所需的类连同它依赖的包存在于类路径中，常见问题在于类名书写错误。</strong></p></li><li><p>另外还有一个导致ClassNotFoundException的原因就是：当一个类已经某个类加载器加载到内存中了，此时另一个类加载器又尝试着动态地从同一个包中加载这个类。<strong>通过控制动态类加载过程，可以避免上述情况发生。</strong></p></li></ul><p>NoClassDefFoundError产生的原因在于：</p><ul><li>如果JVM或者ClassLoader实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候却找不到类的定义。要查找的类在编译的时候是存在的，运行的时候却找不到了。这个时候就会导致NoClassDefFoundError。<strong>造成该问题的原因可能是打包过程漏掉了部分类，或者jar包出现损坏或者篡改。解决这个问题的办法是查找那些在开发期间存在于类路径下但在运行期间却不在类路径下的类。</strong></li></ul><h1 id="final、-finally、-finalize的不同"><a href="#final、-finally、-finalize的不同" class="headerlink" title="final、 finally、 finalize的不同"></a>final、 finally、 finalize的不同</h1><p>final可以用来修饰类、方法、变量，分别有不同的意义， final修饰的class代表不可以继承扩展， final的变量是不可以修改的，而final的方法也是不可以重写的。<br>finally则是Java保证重点代码一定要被执行的一种机制。我们可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接、保证unlock锁等动作。<br>finalize是基础类java.lang.Object的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。 fnalize机制现在已经不推荐使用，并且在JDK 9开始被标记为deprecated  </p><blockquote><p>为什么不推荐使用finalize？简单说，你无法保证fnalize什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。  </p><p>finally不执行的情况：1.system.exit(1)退出 2.无限循环 3.线程被杀死</p></blockquote><h1 id="强引用、软引用、弱引用、幻象引用的区别"><a href="#强引用、软引用、弱引用、幻象引用的区别" class="headerlink" title="强引用、软引用、弱引用、幻象引用的区别"></a>强引用、软引用、弱引用、幻象引用的区别</h1><p>在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用； Java中根据其生命周期的长短，将引用分为4类，不同的引用类型，主要体现的是对象不同的可达性状态和对垃圾收集的影响。</p><ol><li>强引用</li></ol><p>特点：我们平常典型编码Object obj &#x3D; new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足， JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。</p><ol start="2"><li>软引用</li></ol><p>特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收， Java虚拟机就会把这个软引用加入到与之关联的引用<br>队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。<br>应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><ol start="3"><li>弱引用</li></ol><p>特点：弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收， Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br>应用场景：弱应用同样可用于内存敏感的缓存。</p><ol start="4"><li>虚引用</li></ol><p>特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 fnalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span> ();<br><span class="hljs-type">PhantomReference</span> <span class="hljs-variable">pr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span> (object, queue);<br></code></pre></td></tr></table></figure><p>  程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。<br>  应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。    </p><h1 id="反射和动态代理"><a href="#反射和动态代理" class="headerlink" title="反射和动态代理"></a>反射和动态代理</h1><ol><li>关于反射</li></ol><p>反射机制是Java语言提供的一种基础功能，赋予程序在运行时自省的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。反射技术常用在各类通用框架开发中。因为为了保证框架的通用性，需要根据配置文件加载不同的对象或类，并调用不同的方法，这个时候就会用到反射——运行时动态加载需要加载的对象。</p><ol start="2"><li>动态代理</li></ol><p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装RPC调用、面向切面的编程（AOP）。实现动态代理的方式很多，比如JDK自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似ASM、 cglib（基于ASM）、 Javassist等   </p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2023/01/17/%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/01/17/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、知识"><a href="#一、知识" class="headerlink" title="一、知识"></a>一、知识</h1><p>链表并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用，链表分为：单链表、双链表、循环链表。</p><p>链表的插入和删除操作的时间复杂度： O(1) ，链表的随机访问的时间复杂度：O(n) 。</p><p>数组和链表的对比：</p><ol><li>插入、删除、随机访问对比</li></ol><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202301160420509.png" alt="image-20230116042030459"></p><ol start="2"><li>数组的缺点是大小固定，一经声明就要占用整块连续内存空间，链表本身没有大小的限制，天然地支持动态扩容。</li></ol><h1 id="二、应用"><a href="#二、应用" class="headerlink" title="二、应用"></a>二、应用</h1><h2 id="1-如何基于链表实现-LRU-缓存淘汰算法？"><a href="#1-如何基于链表实现-LRU-缓存淘汰算法？" class="headerlink" title="1. 如何基于链表实现 LRU 缓存淘汰算法？"></a>1. 如何基于链表实现 LRU 缓存淘汰算法？</h2><p>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的（或者越靠近尾部的为最新访问的）。</p><p>当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</p><p>如果此数据没有在缓存链表中，又可以分为两种情况：</p><ol><li><p>如果此时缓存未满，则将此结点直接插入到链表的头部；</p></li><li><p>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部；</p></li></ol><p>优化：引入散列表来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。</p><p>具体实现参考<strong>2.LRU缓存</strong>中的第三种方法（单链表+HashMap实现）</p><h2 id="2-LRU-缓存"><a href="#2-LRU-缓存" class="headerlink" title="2.LRU 缓存"></a>2.<a href="https://leetcode.cn/problems/lru-cache-lcci/">LRU 缓存</a></h2><ol><li>使用LinkedHashMap实现</li><li>双向链表+HashMap实现<ul><li>将最近查询的以及最近添加的放入链表的末尾，当链表超过最大长度时，删除头节点所指向的节点（即为最近最少使用的缓存）实现缓存的固定容量</li><li>使用HashMap可以直接判断出链表中是否存在该key的缓存</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-comment">//内部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> val;<br>        <span class="hljs-comment">//前驱节点</span><br>        ListNode pre;<br>        <span class="hljs-comment">//后继节点</span><br>        ListNode next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">()</span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-comment">//头节点、尾节点（对链表的操作更加通用）</span><br>    <span class="hljs-keyword">private</span> ListNode head, tail;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, ListNode&gt; map;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        head.next = tail;<br>        tail.pre = head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-comment">//查看是否存在缓存key</span><br>        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>            <span class="hljs-comment">//将该节点从链表中移除</span><br>            node.pre.next = node.next;<br>            node.next.pre = node.pre;<br>            <span class="hljs-comment">//将该节点添加到链表的末尾</span><br>            moveLast(node);<br>            <span class="hljs-keyword">return</span> node.val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        ListNode node;<br>        <span class="hljs-comment">//可以通过使用查询判断是否存在</span><br>        <span class="hljs-keyword">if</span> (get(key) != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//修改节点的值</span><br>            map.get(key).val = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//创建新的节点</span><br>        node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(key, value);<br>        <span class="hljs-comment">//添加入map</span><br>        map.put(key, node);<br>        <span class="hljs-comment">//移动到链表的末尾</span><br>        moveLast(node);<br>        <span class="hljs-comment">//判断缓存是否超出设置的容量</span><br>        <span class="hljs-keyword">if</span> (map.size() &gt; capacity) &#123;<br>            <span class="hljs-comment">//移除最近最少使用的缓存节点</span><br>            map.remove(head.next.key);<br>            head.next = head.next.next;<br>            head.next.pre = head;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//将节点添加到链表的末尾</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveLast</span><span class="hljs-params">(ListNode node)</span> &#123;<br>        node.pre = tail.pre;<br>        tail.pre.next = node;<br>        node.next = tail;<br>        tail.pre = node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>单链表+HashMap实现<ul><li>使用单链表，最近使用的缓存数据存放在链表的末尾，最近不使用的数据在链表的头部</li><li>hashmap存放key以及key缓存节点对应的前驱节点（key-&gt;其缓存节点的前驱节点）</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> val;<br>        ListNode next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">()</span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> ListNode head, tail;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, ListNode&gt; map;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        tail = head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> node.next;<br>        <span class="hljs-keyword">if</span> (cur != tail) &#123;<br>            <span class="hljs-comment">//从链表移除</span><br>            node.next = cur.next;<br>            <span class="hljs-comment">//修改map</span><br>            map.put(key, tail);<br>            map.put(cur.next.key,node);<br>            moveLast(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        ListNode node;<br>        <span class="hljs-comment">//查询是否存在该key</span><br>        <span class="hljs-keyword">if</span> (get(key) != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//修改该缓存节点的值</span><br>            map.get(key).next.val = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//创建新的节点</span><br>        node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(key, value);<br>        <span class="hljs-comment">//添加缓存数据，key-&gt;该缓存节点的前驱节点</span><br>        map.put(key, tail);<br>        <span class="hljs-comment">//移动到链表的末尾</span><br>        moveLast(node);<br>        <span class="hljs-keyword">if</span> (map.size() &gt; capacity) &#123;<br>            <span class="hljs-comment">//移除map中缓存数据</span><br>            map.remove(head.next.key);<br>            <span class="hljs-comment">//移除链表中的缓存节点</span><br>            head.next = head.next.next;<br>            <span class="hljs-comment">//修改map中的数据，head.next.next的前驱节点为head</span><br>            map.put(head.next.key, head);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//将节点添加到链表的末尾</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveLast</span><span class="hljs-params">(ListNode node)</span> &#123;<br>        tail.next = node;<br>        node.next = <span class="hljs-literal">null</span>;<br>        tail = node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-回文链表"><a href="#3-回文链表" class="headerlink" title="3.回文链表"></a>3.<a href="https://leetcode.cn/problems/aMhZSa/">回文链表</a></h2><ol><li>将链表中的字符串添加至集合中，使用双指针遍历集合判断回文</li><li>使用快慢指针找到链表的中点（链表长度为偶数则为第二个中间），将中点后的链表反转，再将反转链表与原链表dui’bi</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> reverse(slow);<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (node.val != head.val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            node = node.next;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> node;<br>        node = node.next;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> node;<br>            node = node.next;<br>            cur.next = head;<br>            head = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-反转链表"><a href="#4-反转链表" class="headerlink" title="4.反转链表"></a>4.<a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></h2><p>两种方法:</p><ol><li>遍历</li></ol><ul><li>引入头节点，遍历链表，将遍历得到的节点插入到头节点的后一个节点，最后得到的链表为反转链表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">//头节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-comment">//遍历链表</span><br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>            head = head.next;<br>            cur.next = first.next;<br>            first.next = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> first.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>递归</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">//判断是否为null或者为最后一个节点</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">//递归返回反转链表</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> reverseList(head.next);<br>        <span class="hljs-comment">//当前节点置于反转链表末尾</span><br>        head.next.next = head;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-环形链表"><a href="#5-环形链表" class="headerlink" title="5.环形链表"></a>5.<a href="https://leetcode.cn/problems/linked-list-cycle/">环形链表</a></h2><p>使用快慢指针，当链表不存在环时，当节点指向为null时结束，当链表存在环时，快指针和慢指针总会在环中相遇，当快指针和慢指针指向的节点相同时结束循环。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> hasCycle(ListNode head) &#123;<br>    <span class="hljs-comment">//慢指针</span><br>        ListNode slow = head;<br>        <span class="hljs-comment">//快指针</span><br>        ListNode fast = head;<br>        <span class="hljs-comment">//快指针不为null继续</span><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (fast.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//快指针每次经过两个节点</span><br>                fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            slow = slow.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-comment">//判断快慢指针是否相遇</span><br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-合并两个有序链表"><a href="#6-合并两个有序链表" class="headerlink" title="6.合并两个有序链表"></a>6.<a href="https://leetcode.cn/problems/merge-two-sorted-lists/">合并两个有序链表</a></h2><p>创建头节点简化操作，遍历list1和list2链表比较大小，当一个链表遍历完后即可将另一链表直接添加至头节点链表的末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-comment">//头节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//比较大小</span><br>            <span class="hljs-keyword">if</span> (list1.val &gt; list2.val) &#123;<br>                cur.next = list2;<br>                list2 = list2.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = list1;<br>                list1 = list1.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-comment">//将剩余的链表直接插入至头节点所在的链表末尾</span><br>        cur.next = list1 == <span class="hljs-literal">null</span> ? list2 : list1;<br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-删除链表的倒数第-N-个结点"><a href="#7-删除链表的倒数第-N-个结点" class="headerlink" title="7.删除链表的倒数第 N 个结点"></a>7.<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></h2><p>创建头节点（不创建需要对特殊情况进行处理，比如：删除头节点），使用双指针首先快指针现遍历n个节点然后两个指针一同遍历，当快指针指向null时慢指针位于要删除节点的前一节点，接下来进行删除操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>       <span class="hljs-comment">//创建头节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> first;<br>        <span class="hljs-comment">//遍历n个节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        slow.next = slow.next.next;<br>        <span class="hljs-keyword">return</span> first.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-链表的中间结点"><a href="#8-链表的中间结点" class="headerlink" title="8.链表的中间结点"></a>8.<a href="https://leetcode.cn/problems/middle-of-the-linked-list/">链表的中间结点</a></h2><p>使用快慢指针，1. 当链表长度为偶数时，快指针最终指向null时结束遍历，这时慢指针指向链表的第二个中间节点。2. 当链表长度为奇数时，快指针指向最后一个节点结束遍历，这时慢指针指向链表的中间节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言实现UDP服务器</title>
    <link href="/2022/12/28/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0UDP%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/12/28/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0UDP%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TCP-x2F-IP协议与Winsock网络编程接口"><a href="#1-TCP-x2F-IP协议与Winsock网络编程接口" class="headerlink" title="1 TCP&#x2F;IP协议与Winsock网络编程接口"></a>1 TCP&#x2F;IP协议与Winsock网络编程接口</h2><p>为了方便网络编程，20世纪90年代初，Microsoft联合其他几家公司共同制定了一-套Windows下的网络编程接口，即Winsock规范。它不是一种网络协议，而是-一套开放的、支持多种协议的Windows下的网络编程接口。Winsock可以访问很多种网络协议，可以把它当作﹒些协议的封装。现在的Winsock已经基本上实现了与协议无关。可以使用Winsock束调用多种协议的功能。</p><p>那么，Winsock和TCP&#x2F;IP协议到底有什么关系呢?实际上，Winsock就是TCP&#x2F;IP协议的种封装。你可以通过调用Winsock的接口函数来调用TCP&#x2F;IP的各种功能。例如，我们想用TCP&#x2F;IP协议发送数据，就可以使用Winsock的接口函数send()来调用TCP&#x2F;IP的发送数据功能,Winsock已经封装好了发送数据的功能。</p><h2 id="2-Winsock-的常用API"><a href="#2-Winsock-的常用API" class="headerlink" title="2 Winsock 的常用API"></a>2 Winsock 的常用API</h2><h3 id="2-1-WSAStartup函数"><a href="#2-1-WSAStartup函数" class="headerlink" title="2.1 WSAStartup函数"></a>2.1 WSAStartup函数</h3><p>WSAStartup函数的格式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">WSastartup</span><span class="hljs-params">( WORD wversionRequested,LPWSADATA <span class="hljs-number">1</span>pwSAData)</span>;<br></code></pre></td></tr></table></figure><p>程序在使用Socket之前必须调用WSAStartup函数。</p><ul><li><p>该函数的第一个参数指明程序请求使用的Socket版本，其中高位字节指明修订版本、低位字节指明主版本;</p></li><li><p>操作系统利用第二个参数返回请求的Socket的版本信息。当一个应用程序调用WSAStartup函数时，操作系统根据请求的Socket版本来搜索相应的Socket库、然后将找到的Socket库绑定到该应用程序中。以后应用程序就可以调用所请求的Socket库中的其他Socket函数了。</p></li></ul><p>该函数执行成功后返回0。</p><h3 id="2-2-socket函数"><a href="#2-2-socket函数" class="headerlink" title="2.2 socket函数"></a>2.2 socket函数</h3><p>socket函数的格式为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Socket <span class="hljs-title function_">socket</span><span class="hljs-params">( <span class="hljs-type">int</span> af, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol )</span>;<br></code></pre></td></tr></table></figure><p>应用程序调用socket函数来创建一个能够进行网络通信的套接字。</p><ul><li><p>第一个参数指定应用程序使用的通信协议的协议族，如果使用TCP&#x2F;IP协议族，则该参数置PF_INET，设置通信域(本地(PF_LOCAL),ipv4(PF_INET),ipv6(PF_INET6)。</p></li><li><p>第二个参数指定要创建的套接字类型（流套接字类型为SOCK_STREAM，数据报套接字类型为SOCK_DGRAM)。</p></li><li><p>第三个参数指定应用程序所使用的通信协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议。</p></li></ul><p>如果该函数调用成功，则返回新创建的套接字的描述符，如果失败则返回INVALID_SOCKET。套接字描述符是一个整数类型的值。每个进程的进程空间里都有一个套接字描述符表，该表中存放着套接字描述符和套接字数据结构的对应关系。该表用一个字段存放新创建的套接字的描述符，另一个字段存放套接字数据结构的地址，因此根据套接字描述符就可以找到其对应的套接字数据结构。</p><h3 id="2-3-bind函数"><a href="#2-3-bind函数" class="headerlink" title="2.3 bind函数"></a>2.3 bind函数</h3><p>bind函数的格式为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">( SOCKET s,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr FAR *name, <span class="hljs-type">int</span> namelen)</span>;<br></code></pre></td></tr></table></figure><p>当创建了一个Socket以后，套接字数据结构中有一个默认的IP地址和默认的端口号。一个服务程序必须调用bind函数来给Socket绑定一个IP地址和一个特定的端口号。客户程序一般不必调用bind函数来为其Socket绑定IP地址和端口号。该函数的第一个参数指定待绑定的Socket描述符;第二个参数指定一个sockaddr结构，该结构的定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span></span><br><span class="hljs-class">&#123;</span><br>u _short sa_family;<br><br><span class="hljs-type">char</span> sa_data[ <span class="hljs-number">14</span> ];<br>&#125;;<br></code></pre></td></tr></table></figure><p>sa_family指定地址族，对于TCP&#x2F;IP协议族的套接字，将其置AF_INET。当对TCP&#x2F;IP协议族的套接字进行绑定时，我们通常使用如下所示的另一个地址结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span>&#123;</span><br><br>  <span class="hljs-type">sa_family_t</span>     sin_family;   <span class="hljs-comment">//地址族（Address Family），也就是地址类型</span><br><br>  <span class="hljs-type">uint16_t</span>        sin_port;     <span class="hljs-comment">//16位的端口号</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span>  <span class="hljs-title">sin_addr</span>;</span>     <span class="hljs-comment">//32位IP地址    </span><br><br>  <span class="hljs-type">char</span>  sin_zero[<span class="hljs-number">8</span>];  <span class="hljs-comment">//不使用，一般用0填充</span><br> &#125;;<br></code></pre></td></tr></table></figure><p>其中，sin_family置AF_INET; sin_port指明端口号; sin_addr结构体中只有一个唯一的字段s_addr，它表示IP地址。该字段是一个整数，一般用函数inet_addr()把字符串形式的IP地址转换成无符号长整型的整数值后再赋给s_addr。我们用0来填充sin_zero数组，目的是让sockaddr_in结构的大小与sockaddr结构的大小一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span>&#123;<br>   <span class="hljs-type">in_addr_t</span>  s_addr;  <span class="hljs-comment">//32位的IP地址</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>s_addr 是一个整数，而IP地址是一个字符串，所以需要 inet_addr() 函数进行转换将一个无符号短整型数值转换为网络字节序，即大端模式。</p><h3 id="2-4-recvfrom函数"><a href="#2-4-recvfrom函数" class="headerlink" title="2.4 recvfrom函数"></a>2.4 recvfrom函数</h3><p>recefrom为无连接读函数，函数格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">int</span> buf_len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags,<span class="hljs-keyword">struct</span> sockaddr *from,<span class="hljs-type">int</span> fromlen)</span>;<br></code></pre></td></tr></table></figure><p>从UDP接收数据，返回实际接收的字节数，失败时返回-1</p><ul><li><p>Sockfd:套接字描述符</p></li><li><p>buf:指向内存块的指针</p></li><li><p>buf_len:内存块大小，以字节为单位</p></li><li><p>flags:一般为0</p></li><li><p>from:远端的地址，IP地址和端口号</p></li><li><p>fromlen:远端地址长度</p></li></ul><p>举例：recvfrom(sockfd,buf,8192,0,(struct sockaddr *)&amp;address, sizeof(address)); </p><h3 id="2-5-sendto函数"><a href="#2-5-sendto函数" class="headerlink" title="2.5 sendto函数"></a>2.5 sendto函数</h3><p>sendto为无连接函数，函数格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sendto</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * data, <span class="hljs-type">int</span> data_len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags, <span class="hljs-keyword">struct</span> sockaddr *remaddr,<span class="hljs-type">int</span> remaddr_len）</span><br></code></pre></td></tr></table></figure><p>基于UDP发送数据报，返回实际发送的数据长度，出错时返回－1</p><ul><li><p>sockfd:套接字描述符</p></li><li><p>data:指向要发送数据的指针</p></li><li><p>data_len:数据长度</p></li><li><p>flags:通常为0</p></li><li><p>remaddr:远端地址：IP地址和端口号</p></li><li><p>remaddr_len :地址长度</p></li></ul><p>举例：sendto(sockfd,buf,sizeof(buf),0,(struct sockaddr *)&amp;address, sizeof(address)); </p><h3 id="2-6-closesocket函数"><a href="#2-6-closesocket函数" class="headerlink" title="2.6 closesocket函数"></a>2.6 closesocket函数</h3><p>closesocket函数的格式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">closesocket</span> <span class="hljs-params">( SOCKET s )</span> ;<br></code></pre></td></tr></table></figure><p>closesocket函数用来关闭一个描述符为s的套接字。每个进程中都有一个套接字描述符表，表中的每个套接字描述符都与一个位于操作系统缓冲区中的套接字数据结构相对应，有可能有几个套接字描述符指向同一个套接字数据结构。套接字数据结构中专门有一个字段存放该结构被引用的次数，即有多少个套接字描述符指向该结构。closesocket函数如果执行成功就返回0，否则返回SOCKET_ERROR。</p><h3 id="2-7-WSACleanup函数"><a href="#2-7-WSACleanup函数" class="headerlink" title="2.7 WSACleanup函数"></a>2.7 WSACleanup函数</h3><p>WSACleanup函数的格式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">WSAcleanup</span> <span class="hljs-params">( <span class="hljs-type">void</span> )</span> ;<br></code></pre></td></tr></table></figure><p>应用程序在完成对请求的Socket库的使用后，要调用WSACleanup函数来解除与Socket库的绑定并且释放Socket库所占用的系统资源。</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3 代码实现"></a>3 代码实现</h2><h3 id="3-1-服务端代码实现"><a href="#3-1-服务端代码实现" class="headerlink" title="3.1 服务端代码实现"></a>3.1 服务端代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;winsock2.h&gt;</span><span class="hljs-comment">//为socket2.0  </span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 255</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span> &#123;<br><br><span class="hljs-comment">//返回一个无符号16位整形数，高八位（Socket修订版本）和低八位（主版本） </span><br>WORD socketVersion=MAKEWORD(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">//请求的Socket库，这个结构被用来存储被WSAStartup函数调用后返回的Windows Sockets数据</span><br>WSADATA wsadata;<br><br>SOCKET serveSocket;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serveAddr</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">clientAddr</span>;</span><br><br><span class="hljs-type">int</span> len=<span class="hljs-number">-1</span>;<br><br><span class="hljs-type">int</span> addrLen=<span class="hljs-keyword">sizeof</span>(clientAddr);<br><br><span class="hljs-comment">//缓冲数据</span><br><span class="hljs-type">char</span> receiveData[BUF_SIZE];<br><br><span class="hljs-type">char</span> sendData[BUF_SIZE];<br><br><span class="hljs-comment">//初始化socket库</span><br><span class="hljs-keyword">if</span>(WSAStartup(socketVersion,&amp;wsadata)!=<span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket库初始化失败\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//创建socket</span><br>serveSocket=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);<br><br><span class="hljs-keyword">if</span>(serveSocket==INVALID_SOCKET) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket服务器创建失败&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//设置地址类型、端口号、接收地址</span><br>serveAddr.sin_family=AF_INET;<br>serveAddr.sin_port=htons(<span class="hljs-number">15632</span>);<br><span class="hljs-comment">//监听本机的所有接口</span><br>serveAddr.sin_addr.S_un.S_addr= htonl(INADDR_ANY);<br><br><span class="hljs-comment">//socket绑定设置的IP和端口号</span><br><span class="hljs-keyword">if</span>(bind(serveSocket,(SOCKADDR*)&amp;serveAddr,<span class="hljs-keyword">sizeof</span>(serveAddr))==SOCKET_ERROR) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;绑定IP和端口出现问题\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;服务器开始运行\n&quot;</span>);<br><br><span class="hljs-comment">//接收数据</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>len=recvfrom(serveSocket,receiveData,BUF_SIZE<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,(SOCKADDR*)&amp;clientAddr,&amp;addrLen);<br><span class="hljs-keyword">if</span>(len&gt;<span class="hljs-number">0</span>) &#123;<br>receiveData[len]=<span class="hljs-number">0x00</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;接收到一个连接，IP地址为：%s \n&quot;</span>,inet_ntoa(clientAddr.sin_addr));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;客户端：%s \n&quot;</span>,receiveData);<br>&#125;<br><br><span class="hljs-comment">//响应数据</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;服务器：&quot;</span>);<br>fgets(sendData,<span class="hljs-keyword">sizeof</span>(sendData),<span class="hljs-built_in">stdin</span>);<span class="hljs-comment">//标准流 </span><br>sendData[<span class="hljs-built_in">strlen</span>(sendData)<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>; <br>sendto(serveSocket,sendData,<span class="hljs-built_in">strlen</span>(sendData),<span class="hljs-number">0</span>,(SOCKADDR*)&amp;clientAddr,addrLen);<br>&#125;<br><br>closesocket(serveSocket);<br>WSACleanup();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-客户端代码实现"><a href="#3-2-客户端代码实现" class="headerlink" title="3.2 客户端代码实现"></a>3.2 客户端代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;winsock2.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 255</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span> &#123;<br><br>WORD socketVersion=MAKEWORD(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><br>WSADATA wsadata;<br><br>SOCKET clientSocket;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serveAddr</span>;</span><br><br><span class="hljs-type">int</span> len=<span class="hljs-number">-1</span>;<br><br><span class="hljs-type">int</span> addrLen=<span class="hljs-keyword">sizeof</span>(serveAddr);<br><br><br><span class="hljs-comment">//缓冲数据</span><br><span class="hljs-type">char</span> receiveData[BUF_SIZE];<br><br><span class="hljs-type">char</span> sendData[BUF_SIZE];<br><br><span class="hljs-keyword">if</span>(WSAStartup(socketVersion,&amp;wsadata)!=<span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket库初始化失败\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//创建socket</span><br>clientSocket=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);<br><br><span class="hljs-keyword">if</span>(clientSocket==INVALID_SOCKET) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket客户端创建失败\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(argc==<span class="hljs-number">5</span>) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">clientAddr</span>;</span><br>clientAddr.sin_family=AF_INET;<br>clientAddr.sin_addr.S_un.S_addr=inet_addr(argv[<span class="hljs-number">2</span>]);<br>clientAddr.sin_port=htons(atoi(argv[<span class="hljs-number">3</span>]));<br><span class="hljs-keyword">if</span>(bind(clientSocket,(SOCKADDR*)&amp;clientAddr,<span class="hljs-keyword">sizeof</span>(clientAddr))==SOCKET_ERROR) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;绑定IP和端口出现问题\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>serveAddr.sin_family=AF_INET;<br>serveAddr.sin_port=htons(atoi(argv[<span class="hljs-number">5</span>]));<br>serveAddr.sin_addr.S_un.S_addr=inet_addr(argv[<span class="hljs-number">4</span>]);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//设置地址类型、端口号、接收地址</span><br>serveAddr.sin_family=AF_INET;<br>serveAddr.sin_port=htons(<span class="hljs-number">15632</span>);<br>serveAddr.sin_addr.S_un.S_addr=inet_addr(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">//收发数据</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-comment">//发送数据</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;客户端：&quot;</span>);<br>fgets(sendData,<span class="hljs-keyword">sizeof</span>(sendData),<span class="hljs-built_in">stdin</span>);<br>sendData[<span class="hljs-built_in">strlen</span>(sendData)<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-comment">//不再发送数据</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(sendData,<span class="hljs-string">&quot;bye&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send OK!\n&quot;</span>);<br><br><br>sendto(clientSocket,sendData,<span class="hljs-built_in">strlen</span>(sendData),<span class="hljs-number">0</span>,(SOCKADDR*)&amp;serveAddr,addrLen);<br><span class="hljs-comment">//接收数据</span><br>len=recvfrom(clientSocket,receiveData,BUF_SIZE<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,(SOCKADDR*)&amp;serveAddr,&amp;addrLen);<br><span class="hljs-keyword">if</span>(len&gt;<span class="hljs-number">0</span>) &#123;<br>receiveData[len]=<span class="hljs-number">0x00</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;服务器：%s \n&quot;</span>,receiveData);<br>&#125;<br><br>&#125;<br><br>closesocket(clientSocket);<br>WSACleanup();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-遇到的问题"><a href="#4-遇到的问题" class="headerlink" title="4 遇到的问题"></a>4 遇到的问题</h2><h3 id="4-1-undefined-reference-to’WSAStartup’相关编译错误"><a href="#4-1-undefined-reference-to’WSAStartup’相关编译错误" class="headerlink" title="4.1 undefined reference to’WSAStartup’相关编译错误"></a>4.1 undefined reference to’WSAStartup’相关编译错误</h3><p>打开dev-C++的工具-&gt;编译选项，添加-lws2_32命令即可解决，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202212281323563.png" alt="image-20221228132347388"></p><p><strong>参考资料</strong></p><p><a href="http://c.biancheng.net/view/2359.html">基于UDP的服务器端和客户端 (biancheng.net)</a></p><p><a href="https://blog.csdn.net/qq_31869107/article/details/81234785?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-81234785-blog-111029316.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-81234785-blog-111029316.pc_relevant_recovery_v2&utm_relevant_index=5">Dev C++的undefined reference to ‘__imp_htons’或codeclock的undefined reference to’WSAStartup to@8’相关编译器错</a></p>]]></content>
    
    
    <categories>
      
      <category>计网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
      <tag>UDP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eNSP的使用</title>
    <link href="/2022/12/04/eNSP%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/12/04/eNSP%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、eNSP软件是什么？"><a href="#一、eNSP软件是什么？" class="headerlink" title="一、eNSP软件是什么？"></a>一、eNSP软件是什么？</h1><p>eNSP(Enterprise Network Simulation Platform)是一款由华为提供的、可扩展的、图形化操作的网络仿真工具平台，主要对企业网络路由器、交换机进行软件仿真，完美呈现真实设备实景，支持大型网络模拟，让广大用户有机会在没有真实设备的情况下能够模拟演练，学习网络技术。</p><blockquote><p>以上解释来自于百度百科</p></blockquote><h1 id="二、eNSP软件安装"><a href="#二、eNSP软件安装" class="headerlink" title="二、eNSP软件安装"></a>二、eNSP软件安装</h1><h2 id="2-1-安装包"><a href="#2-1-安装包" class="headerlink" title="2.1 安装包"></a>2.1 安装包</h2><p>由于现在华为官网没有提供eNSP的安装包了，所以需要下载的同学应到网上寻找资源下载对应的版本，下载完之后进入安装界面，只需一直点击下一步即可，安装eNSP的时候会附带安装VirtualBox、Wireshark。</p><h2 id="2-2-安装遇到的坑"><a href="#2-2-安装遇到的坑" class="headerlink" title="2.2 安装遇到的坑"></a>2.2 安装遇到的坑</h2><p>由于个人找到的eNSP版本为1.2.00.510，其附带安装的VirtualBox（版本是5左右的）无法在Windows上运行，所以将其卸载后安装版本6的，但是eNSP不支持，最后看到一篇关于解决VirtualBox不兼容问题的博客，然后将其换为VirtualBox-5.2.44-139111-Win该版本后问题解决。</p><h1 id="三、eNSP的使用"><a href="#三、eNSP的使用" class="headerlink" title="三、eNSP的使用"></a>三、eNSP的使用</h1><h2 id="3-1-主页"><a href="#3-1-主页" class="headerlink" title="3.1 主页"></a>3.1 主页</h2><div align="center"><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211220146783.png" height="60%" width="80%"></div><p>上图所示即为eNSP打开的界面，上面为功能栏，左侧为一些实验器材，中间的样例即为自带可运行的示例，学习提供了关于eNSP的一些使用文档和介绍。</p><h2 id="3-2-拓扑页"><a href="#3-2-拓扑页" class="headerlink" title="3.2 拓扑页"></a>3.2 拓扑页</h2><div align="center"><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211220154865.png" height="60%" width="80%"></div><p>中间即为实验区域，左侧为实验的设备。</p><h3 id="PC配置"><a href="#PC配置" class="headerlink" title="PC配置"></a>PC配置</h3><div align="center"><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211220158012.png" height="40%" width="60%"></div><p>通过PC的配置页面进行IP地址、子网掩码、网关的配置，网关即为该PC连接的路由的IP地址，可以通过对路由器进行DHCP配置，选择DHCP自动分配IP地址。</p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><div align="center"><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211220204861.png" height="40%" width="40%"></div><p>一般常用的路由器即为AR2220、Router路由器，可用通过选择CLI或者双击路由器图标进入类似于DOS黑窗口中进行配置。首先sys进入然后通过 int  g0&#x2F;0&#x2F;0(端点号)选择对应端点，通过ip add ip地址 地址掩码设置该端点的ip地址。</p><h4 id="设置ripv2"><a href="#设置ripv2" class="headerlink" title="设置ripv2"></a>设置ripv2</h4><ol><li><p>对路由器进行配置：rip （进入rip协议的配置）</p></li><li><p>Version 2（选择RIP的版本）</p></li><li><p>Network 网络地址（与该路由直连的网络地址）</p></li><li><p>对相连的路由器都使用以上配置。</p></li><li><p>配置完成后使用dis ip routing-table命令查看路由表，表中存在rip协议的路由对应数据，即为配置成功</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202212041710885.png" alt="image-20221204171038773"></p><h4 id="设置DHCP"><a href="#设置DHCP" class="headerlink" title="设置DHCP"></a>设置DHCP</h4><ol><li><p>Dhcp enable开启DHCP服务</p></li><li><p>Ip pool pool1创建全局地址池pool1</p></li><li><p>getway-list 网关地址 设置分配的网关地址</p></li><li><p>network ip地址 mask 子网掩码 设置全局地址池的范围</p></li><li><p>dns-list 主要DNS 备用DNS 设置DNS</p></li><li><p>excluded-ip-address ip地址 ip地址 设置不参与动态分配的地址，可以是一个范围</p></li><li><p>再进入对应的接口，dhcp select global开启全局地址分配ip</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202212041712625.png" alt="image-20221204171236569"></p><h2 id="3-3-交换机"><a href="#3-3-交换机" class="headerlink" title="3.3 交换机"></a>3.3 交换机</h2><p>ensp中S5700交换机为三层交换机，你可以为它设置ip地址，若无需要可直接使用。</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>以上为本人完成计网作业的一些总结，希望可以帮助到大家。</p><p><strong>参考资料</strong></p><p><a href="https://blog.csdn.net/lushixuan12345/article/details/124227195">【eNSP】解决virtualbox不兼容&#x2F;无法运行问题_擅长开发Bug的Mr.NaCl的博客-CSDN博客</a></p><p><a href="https://www.bilibili.com/read/cv14351927">eNSP的DHCP的三种配置 - 哔哩哔哩 (bilibili.com)</a></p><p><a href="https://blog.csdn.net/weixin_48711866/article/details/121604408">华为ensp路由器动态RIP协议配置</a></p>]]></content>
    
    
    <categories>
      
      <category>计网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
      <tag>ensp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译及运行错误</title>
    <link href="/2022/11/16/%E7%BC%96%E8%AF%91%E5%8F%8A%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF/"/>
    <url>/2022/11/16/%E7%BC%96%E8%AF%91%E5%8F%8A%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="一、编译及运行出错"><a href="#一、编译及运行出错" class="headerlink" title="一、编译及运行出错"></a>一、编译及运行出错</h1><blockquote><p>在一次作业中，将java文件上传至Linux服务器，使用javac命令进行编译，之后用java命令运行编译文件，出现找不到主类，之后想在本地使用命令行运行查找问题，结果直接编译出错，故写下该篇文章记录问题。</p></blockquote><h2 id="1-运行出错"><a href="#1-运行出错" class="headerlink" title="1. 运行出错"></a>1. 运行出错</h2><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211162057891.png" alt="运行出错"></p><p>java程序在Linux运行错误原因：java文件中带有包名，编译后的class文件应该放在该包下，使用以下命令运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java 包名.类名<br></code></pre></td></tr></table></figure><h2 id="2-编译出错"><a href="#2-编译出错" class="headerlink" title="2. 编译出错"></a>2. 编译出错</h2><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211162059530.png" alt="image-20221116205933493"></p><ol><li>Java程序在编译的时候，需要使用JDK开发工具包中的JAVAC.EXE命令，而JDK开发工具包是国际版的，默认是对Unicode的编码格式的源文件进行编译操作。</li><li>因此其他编码格式的源文件需要先转为Unicode格式才能够进行编译。</li><li>在未指定源程序文件的编码格式的情况下，JDK会优先获取操作系统的file.encoding参数，然后JDK就把我们的JAVA源程序从file.encoding编码格式转化为JAVA内部默认的Unicode格式放到内存中。</li><li><strong>如果源文件的编码格式不是file.encoding，就会出现乱码-不能够正确对应的中文而报错。</strong></li><li>javac把转换后的Unicode格式的文件进行编译成class类文件，此时.class文件是Unicode编码的，它暂放在内存中。之后，JDK将此以Unicode编码编译后的.class文件保存到操作系统中形成我们见到的.class文件。</li></ol><p><strong>解决方法</strong>：</p><ol><li>将java文件以ASCII编码格式保存</li><li>使用以下命令进行java程序的编译</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">javac -encoding UTF-8 文件名.java<br></code></pre></td></tr></table></figure><p><strong>参考文章</strong></p><p><a href="https://blog.csdn.net/Tsing1644/article/details/107375558?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-5-107375558-blog-106419663.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-5-107375558-blog-106419663.pc_relevant_default&utm_relevant_index=9">解析java程序编译时编码GBK的不可映射字符的错误</a></p>]]></content>
    
    
    <categories>
      
      <category>问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA建立多级包</title>
    <link href="/2022/11/10/IDEA%E5%BB%BA%E7%AB%8B%E5%A4%9A%E7%BA%A7%E5%8C%85/"/>
    <url>/2022/11/10/IDEA%E5%BB%BA%E7%AB%8B%E5%A4%9A%E7%BA%A7%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="一、建立多级包"><a href="#一、建立多级包" class="headerlink" title="一、建立多级包"></a>一、建立多级包</h1><blockquote><p>由于本人隔一段时间就会遇到该问题并且每次都忘记方法需要查找资料，故写下该片博客记录</p></blockquote><h2 id="1-1-建立Package"><a href="#1-1-建立Package" class="headerlink" title="1.1 建立Package"></a>1.1 建立Package</h2><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101716505.png" alt="步骤一"></p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101717810.png" alt="步骤二"></p><p>建立多级package<strong>中间用.分割</strong></p><h2 id="1-2-建立Directionary"><a href="#1-2-建立Directionary" class="headerlink" title="1.2 建立Directionary"></a>1.2 建立Directionary</h2><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101719735.png" alt="步骤一"></p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101720925.png" alt="步骤二"></p><p>建立多级directionary<strong>中间用&#x2F;分割</strong>，<strong>不能使用.分割，使用.分割建立的为单级directionary</strong></p><h1 id="二、-解决多级包不分离问题"><a href="#二、-解决多级包不分离问题" class="headerlink" title="二、 解决多级包不分离问题"></a>二、 解决多级包不分离问题</h1><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101726557.png" alt="步骤一"></p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101728575.png" alt="步骤二"></p><p>取消选择：Compact Middle Packages，多级目录分离</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202211101729695.png" alt="步骤三"></p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
      <tag>问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2022/10/30/%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/10/30/%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一、反射机制"><a href="#一、反射机制" class="headerlink" title="一、反射机制"></a>一、反射机制</h1><p>反射机制允许程序在执行期借助Reflection API取得任何类的内部信息（比如成员变量、构造器、成员方法等）并能操作对象的属性和方法，反射在设计模式和框架底层都会用到。</p><p>加载完类之后，在堆中就会产生一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202210301944451.png" alt="三个阶段"></p><h2 id="1-1-Java反射机制可以完成"><a href="#1-1-Java反射机制可以完成" class="headerlink" title="1.1 Java反射机制可以完成"></a>1.1 Java反射机制可以完成</h2><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时得到任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ol><h2 id="1-2-反射主要的类"><a href="#1-2-反射主要的类" class="headerlink" title="1.2 反射主要的类"></a>1.2 反射主要的类</h2><p>java.lang.Class 代表一个类，Class对象表示某个类加载后在堆中的对象</p><p>java.lang.reflect.Method 代表类的方法，Method对象表示某个类的方法</p><p>java.lang.reflect.Field 代表类的成员变量，Field对象表示某个类的成员变量</p><p>java.lang.reflect.Constructor 代表类的构造方法，Constructor对象表示某个类的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//使用反射解决</span><br>    <span class="hljs-comment">//加载类，返回Class类型的对象cls</span><br>    Class cls=Class.forName(<span class="hljs-string">&quot;类的全限定名&quot;</span>);<br>    <span class="hljs-comment">//通过cls获取对象的实例，无参构造器创建</span><br>    Object o=cls.newInstance();<br>    System.out.println(o.getClass());<br>    <span class="hljs-comment">//获取方法对象，将方法看做对象（万物皆对象）</span><br>    <span class="hljs-comment">//只能获取public修饰的方法</span><br>    Method method1=cls.getMethod(<span class="hljs-string">&quot;方法名&quot;</span>);<br>    <span class="hljs-comment">//通过method1调用方法</span><br>    System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>    <span class="hljs-comment">//传统：对象.方法()，反射机制 方法.invoke()</span><br>    method1.invoke(o);<br><br>    <span class="hljs-comment">//Field对象表示表示类的属性</span><br>    <span class="hljs-comment">//getField只能获取public修饰的属性</span><br>    Field nameField=cls.getField(<span class="hljs-string">&quot;属性名&quot;</span>);<br>    System.out.println(nameField.get(o));<br><br>    <span class="hljs-comment">//Constructor对象表示构造器，只能获取public修饰的构造器</span><br>    <span class="hljs-comment">//若无指定类型，获取无参构造器对象</span><br>    Constructor constructor=cls.getConstructor();<br>    System.out.println(constructor);<br><br>    <span class="hljs-comment">//获取有参构造器对象</span><br>    Constructor constructor1=cls.getConstructor(String.class);<br>    System.out.println(constructor1);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-反射优点和缺点"><a href="#1-3-反射优点和缺点" class="headerlink" title="1.3 反射优点和缺点"></a>1.3 反射优点和缺点</h2><p>优点：可以动态的创建和使用对象，使用领灵活，没有反射机制，框架技术失去底层支撑</p><p>缺点：使用反射基本是解释执行，对执行速度有影响</p><h2 id="1-4-反射调用优化"><a href="#1-4-反射调用优化" class="headerlink" title="1.4 反射调用优化"></a>1.4 反射调用优化</h2><p>Method、Field、Constructor对象都有setAccessible()方法，其作用是启动和禁用访问安全检查的开关，参数为true表示反射的对象在使用时取消访问检查，提高反射效率。参数值为false表示反射的对象执行访问检查。</p><h1 id="二、Class类"><a href="#二、Class类" class="headerlink" title="二、Class类"></a>二、Class类</h1><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/image-20221030145407804.png" alt="Class类图"></p><ol><li>如图，Class也是类，继承Object类</li><li>Class类对象不是new出来的，而是系统创建的</li><li>对于某个类的Class类对象，在内存中只有一份，类只加载一次</li><li>每个类的实例都会记得自己由哪个Class实例所生成的</li><li>通过Class的一系列API可以完整的得到一个类的完整结构</li><li>Class对象存放在堆中</li><li>类的字节码二进制数据，放在方法区的，有的地方称为类的元数据（包含方法代码、变量名、方法名、访问权限等）</li></ol><h2 id="2-1-Class类的常用方法"><a href="#2-1-Class类的常用方法" class="headerlink" title="2.1 Class类的常用方法"></a>2.1 Class类的常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;<br>    <span class="hljs-comment">//需要通过反射创建的类的全限定名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">classFullPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;base.reflection.pojo.Cat&quot;</span>;<br>    <span class="hljs-comment">//获取Cat类对应的Class对象</span><br>    <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(classFullPath);<br>    <span class="hljs-comment">//显示cls对象是哪个类的Class对象</span><br>    System.out.println(cls);<br>    <span class="hljs-comment">//输出cls运行类型</span><br>    System.out.println(cls.getClass());<br>    <span class="hljs-comment">//得到包名</span><br>    System.out.println(cls.getPackage().getName());<br>    <span class="hljs-comment">//得到全类名</span><br>    System.out.println(cls.getName());<br>    <span class="hljs-comment">//通过cls创建对象实例</span><br>    <span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> (Cat) cls.newInstance();<br>    System.out.println(cat);<br>    <span class="hljs-comment">//获取对象属性</span><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> cls.getField(<span class="hljs-string">&quot;age&quot;</span>);<br>    System.out.println(age.get(cat));<br>    <span class="hljs-comment">//通过反射给属性赋值</span><br>    age.set(cat, <span class="hljs-number">20</span>);<br>    <span class="hljs-comment">//获取所有public修饰的属性</span><br>    Field[] fields = cls.getFields();<br>    <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>        System.out.println(field);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-获取Class类对象的方法"><a href="#2-2-获取Class类对象的方法" class="headerlink" title="2.2 获取Class类对象的方法"></a>2.2 获取Class类对象的方法</h2><ol><li>已知一个类的全类名，而且类在类路径下，可通过Class的静态方法forName()获取。应用场景：多用于配置文件、读取类的全路径，加载类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;类的全路径&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高。应用场景：多用于参数传递</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls2=Cat.class;<br></code></pre></td></tr></table></figure><ol start="3"><li>已知某个类的实例，调用该实例的getClass()方法获取Class对象。应用场景：通过创建好的对象，获取Class对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls3=cat.getClass();<br></code></pre></td></tr></table></figure><ol start="4"><li>通过类加载器创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassLoader cl=对象.getClass().getClassLoader();<br>Class cls4=cl.loadClass(<span class="hljs-string">&quot;类的全类名&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="5"><li>基本数据类型（八种）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls=基本数据类型.class<br></code></pre></td></tr></table></figure><ol start="6"><li>基本数据类型对应的包装类，可以通过.TYPE得到Class对象(获取的是基本数据类型的Class对象)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls=包装类.TYPE<br></code></pre></td></tr></table></figure><blockquote><p>相同的基本类型和包装类.TYPE获取的Class类对象是同一个</p></blockquote><h2 id="2-3-具有Class对象的类型"><a href="#2-3-具有Class对象的类型" class="headerlink" title="2.3 具有Class对象的类型"></a>2.3 具有Class对象的类型</h2><ol><li>外部类、成员内部类、静态内部类、局部内部类、匿名内部类</li><li>interface：接口</li><li>数组</li><li>enum：枚举</li><li>annotation：注解</li><li>基本数据类型</li><li>void</li></ol><h1 id="三、类加载"><a href="#三、类加载" class="headerlink" title="三、类加载"></a>三、类加载</h1><p>反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载</p><ol><li>静态加载：编译时加载相关的类，如果不存在则报错，依赖性太强</li><li>动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，则不报错，降低了依赖性</li></ol><p><strong>类的加载时机</strong></p><ul><li>当创建对象时（静态加载）</li><li>当子类被加载时，父类也加载（静态加载）</li><li>调用类中的静态成员时（静态加载）</li><li>通过反射（动态加载）</li></ul><p><strong>类的加载过程</strong></p><p>java源码编译为字节码文件进行类的加载（类的加载分为三个阶段，如图），类加载后内存布局情况：类的字节码（二进制数据）存放于方法区，类的Class对象存放于堆区。</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/202210301945424.png" alt="类的加载过程"></p><h2 id="3-1-加载阶段"><a href="#3-1-加载阶段" class="headerlink" title="3.1 加载阶段"></a>3.1 加载阶段</h2><p>JVMZ在该阶段的主要目的是将字节码从不同的数据源（可能是class文件、也可能是jar包，甚至网络）转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</p><h2 id="3-2-连接阶段"><a href="#3-2-连接阶段" class="headerlink" title="3.2 连接阶段"></a>3.2 连接阶段</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ol><li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li><li>包括：文件格式验证、元数据验证、字节码验证和符号引用验证</li><li>可以使用-Xverify:none参数关闭大部分的类验证措施，缩短虚拟机加载的时间</li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>JVM会在该阶段对静态变量，分配内存并默认初始化。这些变量所使用的内存都将在方法去中进行分配</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>虚拟机将常量池内的符号引用替换为直接引用的过程</p><h2 id="3-3-初始化"><a href="#3-3-初始化" class="headerlink" title="3.3 初始化"></a>3.3 初始化</h2><ol><li>到初始化阶段才真正开始执行类中定义的Java程序代码，此阶段是执行<clinit>()方法的过程</li><li><clinit>()方法由编译器按语句在源文件中出现的顺序，依次自动收集类中所有的静态变量的赋值动作和静态代码块中的语句，并进行合并。</li><li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁，同步。如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。</li></ol><h1 id="四、反射相关方法的使用"><a href="#四、反射相关方法的使用" class="headerlink" title="四、反射相关方法的使用"></a>四、反射相关方法的使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">public</span> Integer id;<br>    <span class="hljs-keyword">private</span> String address;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(Integer id, String address)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(Integer id)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;编号为：&quot;</span>+id+<span class="hljs-string">&quot;的汽车开始运行&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restart</span><span class="hljs-params">(String address)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;原产地为：&quot;</span>+address+<span class="hljs-string">&quot;的汽车重启&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Car&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, address=&#x27;&quot;</span> + address + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class cls=Class.forName(<span class="hljs-string">&quot;base.reflection.pojo.Car&quot;</span>);<br><br>    <span class="hljs-comment">//无参构造获取car实例</span><br>    Object o=cls.newInstance();<br>    System.out.println(o);<br>    System.out.println(Integer.class);<br>    <span class="hljs-comment">//通过public修饰的构造器创建对象</span><br>    Constructor constructor=cls.getConstructor(Integer.class);<br>    Object o1=constructor.newInstance(<span class="hljs-number">126</span>);<br>    System.out.println(o1);<br>    <span class="hljs-comment">//通过private修饰的构造器创建对象</span><br>    Constructor constructor1=cls.getDeclaredConstructor(Integer.class,String.class);<br>    <span class="hljs-comment">//未设置为true，则不能修改或使用私有属性和方法（下同）</span><br>    constructor1.setAccessible(<span class="hljs-literal">true</span>);<br>    Object o2=constructor1.newInstance(<span class="hljs-number">100</span>,<span class="hljs-string">&quot;新西兰&quot;</span>);<br>    System.out.println(o2);<br><br><br>    <span class="hljs-comment">//修改o的public修饰的属性</span><br>    Field fieldId=cls.getField(<span class="hljs-string">&quot;id&quot;</span>);<br>    fieldId.set(o,<span class="hljs-number">123</span>);<br>    <span class="hljs-comment">//修改o的private修饰的属性</span><br>    Field fieldAddress=cls.getDeclaredField(<span class="hljs-string">&quot;address&quot;</span>);<br>    fieldAddress.setAccessible(<span class="hljs-literal">true</span>);<br>    fieldAddress.set(o,<span class="hljs-string">&quot;冰岛&quot;</span>);<br>    System.out.println(o);<br><br>    <span class="hljs-comment">//调用o的方法</span><br>    Method methodStart=cls.getMethod(<span class="hljs-string">&quot;start&quot;</span>,Integer.class);<br>    methodStart.invoke(o,<span class="hljs-number">6</span>);<br>    <span class="hljs-comment">//调用o的private的方法</span><br>    Method methodRestart=cls.getDeclaredMethod(<span class="hljs-string">&quot;restart&quot;</span>,String.class);<br>    methodRestart.setAccessible(<span class="hljs-literal">true</span>);<br>    methodRestart.invoke(o,<span class="hljs-string">&quot;英国&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>视频资料</strong>：<a href="https://www.bilibili.com/video/BV1g84y1F7df/?from=search&seid=12408684664800836462&spm_id_from=333.337.0.0&vd_source=8e40d0a91b994e176587f5593e189b6a">【韩顺平讲Java】Java反射专题</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云服务器安装Redis</title>
    <link href="/2022/10/25/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Redis/"/>
    <url>/2022/10/25/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="一、安装Redis"><a href="#一、安装Redis" class="headerlink" title="一、安装Redis"></a>一、安装Redis</h2><ol><li>从redis的官网下载redis的安装包，redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></li><li>将redis的安装包通过Xftp上传到云服务上，自己选择一个文件夹存放redis安装包并进行解压</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xzf redis-7.0.0.tar.gz<br></code></pre></td></tr></table></figure><p>解压后如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/image-20221020134406224.png" alt="image-20221020134406224"></p><ol start="3"><li>Redis是基于C语言编写的，需要安装Redis所需要的gcc依赖，使用如下命令安装依赖</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum install -y gcc tcl<br></code></pre></td></tr></table></figure><ol start="4"><li>进入解压后的redis目录,运行编译命令,redis默认的安装路径是在 <code>/usr/local/bin</code>目录下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">make &amp;&amp; make install<br></code></pre></td></tr></table></figure><h2 id="二、开启远程连接"><a href="#二、开启远程连接" class="headerlink" title="二、开启远程连接"></a>二、开启远程连接</h2><ol><li>先找到redis.conf文件，将文件中的bind 127.0.0.1 -::1注释，不然只允许127.0.0.1连接，如下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#bind 127.0.0.1 -::1</span><br></code></pre></td></tr></table></figure><blockquote><p>bind ip是将指定的ip设置为redis的对外开放地址</p></blockquote><ol start="2"><li>将daemonize no修改为damemonize yes，即可后台运行redis</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">daemonize <span class="hljs-built_in">yes</span> <br></code></pre></td></tr></table></figure><ol start="3"><li>查找 # requirepass foobared，将注释去掉，设置连接密码</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">requirepass</span> 连接密码<br></code></pre></td></tr></table></figure><ol start="4"><li>启动redis</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-server redis.conf<br></code></pre></td></tr></table></figure><ol start="5"><li>本地连接redis成功<br><img src="https://cdn.jsdelivr.net/gh/PursueMilk/img@master/img/image-20221020140807427.png" alt="image-20221020140807427"></li></ol>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
